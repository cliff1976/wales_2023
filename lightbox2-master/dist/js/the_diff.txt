2,3c2,3
<  * jQuery JavaScript Library v2.1.4
<  * http://jquery.com/
---
>  * jQuery JavaScript Library v3.4.1
>  * https://jquery.com/
6c6
<  * http://sizzlejs.com/
---
>  * https://sizzlejs.com/
8c8
<  * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
---
>  * Copyright JS Foundation and other contributors
10c10
<  * http://jquery.org/license
---
>  * https://jquery.org/license
12c12
<  * Date: 2015-04-28T16:01Z
---
>  * Date: 2019-05-01T21:04Z
13a14
> ( function( global, factory ) {
15c16
< (function( global, factory ) {
---
> 	"use strict";
17a19
> 
38c40
< }(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
---
> } )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
40,44c42,46
< // Support: Firefox 18+
< // Can't be in strict mode, several libs including ASP.NET trace
< // the stack via arguments.caller.callee and Firefox dies if
< // you try to trace through "use strict" call chains. (#13335)
< //
---
> // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
> // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
> // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
> // enough that all such attempts are guarded in a try block.
> "use strict";
47a50,53
> var document = window.document;
> 
> var getProto = Object.getPrototypeOf;
> 
61a68,71
> var fnToString = hasOwn.toString;
> 
> var ObjectFunctionString = fnToString.call( Object );
> 
63a74
> var isFunction = function isFunction( obj ) {
64a76,81
>       // Support: Chrome <=57, Firefox <=52
>       // In some browsers, typeof returns "function" for HTML <object> elements
>       // (i.e., `typeof document.createElement( "object" ) === "function"`).
>       // We don't want to classify *any* DOM node as a function.
>       return typeof obj === "function" && typeof obj.nodeType !== "number";
>   };
66,68d82
< var
< 	// Use the correct document accordingly with window argument (sandbox)
< 	document = window.document,
70c84,145
< 	version = "2.1.4",
---
> var isWindow = function isWindow( obj ) {
> 		return obj != null && obj === obj.window;
> 	};
> 
> 
> 
> 
> 	var preservedScriptAttributes = {
> 		type: true,
> 		src: true,
> 		nonce: true,
> 		noModule: true
> 	};
> 
> 	function DOMEval( code, node, doc ) {
> 		doc = doc || document;
> 
> 		var i, val,
> 			script = doc.createElement( "script" );
> 
> 		script.text = code;
> 		if ( node ) {
> 			for ( i in preservedScriptAttributes ) {
> 
> 				// Support: Firefox 64+, Edge 18+
> 				// Some browsers don't support the "nonce" property on scripts.
> 				// On the other hand, just using `getAttribute` is not enough as
> 				// the `nonce` attribute is reset to an empty string whenever it
> 				// becomes browsing-context connected.
> 				// See https://github.com/whatwg/html/issues/2369
> 				// See https://html.spec.whatwg.org/#nonce-attributes
> 				// The `node.getAttribute` check was added for the sake of
> 				// `jQuery.globalEval` so that it can fake a nonce-containing node
> 				// via an object.
> 				val = node[ i ] || node.getAttribute && node.getAttribute( i );
> 				if ( val ) {
> 					script.setAttribute( i, val );
> 				}
> 			}
> 		}
> 		doc.head.appendChild( script ).parentNode.removeChild( script );
> 	}
> 
> 
> function toType( obj ) {
> 	if ( obj == null ) {
> 		return obj + "";
> 	}
> 
> 	// Support: Android <=2.3 only (functionish RegExp)
> 	return typeof obj === "object" || typeof obj === "function" ?
> 		class2type[ toString.call( obj ) ] || "object" :
> 		typeof obj;
> }
> /* global Symbol */
> // Defining this global in .eslintrc.json would create a danger of using the global
> // unguarded in another place, it seems safer to define global only for this module
> 
> 
> 
> var
> 	version = "3.4.1",
73a149
> 
79c155
< 	// Support: Android<4.1
---
> 	// Support: Android <=4.0 only
81,90c157
< 	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
< 
< 	// Matches dashed string for camelizing
< 	rmsPrefix = /^-ms-/,
< 	rdashAlpha = /-([\da-z])/gi,
< 
< 	// Used by jQuery.camelCase as callback to replace()
< 	fcamelCase = function( all, letter ) {
< 		return letter.toUpperCase();
< 	};
---
> 	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
92a160
> 
98,100d165
< 	// Start with an empty selector
< 	selector: "",
< 
111d175
< 		return num != null ?
113,114c177,180
< 			// Return just the one element from the set
< 			( num < 0 ? this[ num + this.length ] : this[ num ] ) :
---
> 		// Return all the elements in a clean array
> 		if ( num == null ) {
> 			return slice.call( this );
> 		}
116,117c182,183
< 			// Return all the elements in a clean array
< 			slice.call( this );
---
> 		// Return just the one element from the set
> 		return num < 0 ? this[ num + this.length ] : this[ num ];
129d194
< 		ret.context = this.context;
136,139c201,202
< 	// (You can seed the arguments with an array of args, but this is
< 	// only used internally.)
< 	each: function( callback, args ) {
< 		return jQuery.each( this, callback, args );
---
> 	each: function( callback ) {
> 		return jQuery.each( this, callback );
143c206
< 		return this.pushStack( jQuery.map(this, function( elem, i ) {
---
> 		return this.pushStack( jQuery.map( this, function( elem, i ) {
145c208
< 		}));
---
> 		} ) );
163c226
< 		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
---
> 		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
167c230
< 		return this.prevObject || this.constructor(null);
---
> 		return this.prevObject || this.constructor();
179c242
< 		target = arguments[0] || {},
---
> 		target = arguments[ 0 ] || {},
194c257
< 	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
---
> 	if ( typeof target !== "object" && !isFunction( target ) ) {
204a268
> 
206c270,271
< 		if ( (options = arguments[ i ]) != null ) {
---
> 		if ( ( options = arguments[ i ] ) != null ) {
> 
209d273
< 				src = target[ name ];
211a276
> 				// Prevent Object.prototype pollution
213c278
< 				if ( target === copy ) {
---
> 				if ( name === "__proto__" || target === copy ) {
218,222c283,291
< 				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
< 					if ( copyIsArray ) {
< 						copyIsArray = false;
< 						clone = src && jQuery.isArray(src) ? src : [];
< 
---
> 				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
> 					( copyIsArray = Array.isArray( copy ) ) ) ) {
> 					src = target[ name ];
> 
> 					// Ensure proper type for the source value
> 					if ( copyIsArray && !Array.isArray( src ) ) {
> 						clone = [];
> 					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
> 						clone = {};
224c293
< 						clone = src && jQuery.isPlainObject(src) ? src : {};
---
> 						clone = src;
225a295
> 					copyIsArray = false;
242c312,313
< jQuery.extend({
---
> jQuery.extend( {
> 
255,272d325
< 	isFunction: function( obj ) {
< 		return jQuery.type(obj) === "function";
< 	},
< 
< 	isArray: Array.isArray,
< 
< 	isWindow: function( obj ) {
< 		return obj != null && obj === obj.window;
< 	},
< 
< 	isNumeric: function( obj ) {
< 		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
< 		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
< 		// subtraction forces infinities to NaN
< 		// adding 1 corrects loss of precision from parseFloat (#15100)
< 		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
< 	},
< 
274,278c327,331
< 		// Not plain objects:
< 		// - Any object or value whose internal [[Class]] property is not "[object Object]"
< 		// - DOM nodes
< 		// - window
< 		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
---
> 		var proto, Ctor;
> 
> 		// Detect obvious negatives
> 		// Use toString instead of jQuery.type to catch host objects
> 		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
282,284c335,339
< 		if ( obj.constructor &&
< 				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
< 			return false;
---
> 		proto = getProto( obj );
> 
> 		// Objects with no prototype (e.g., `Object.create( null )`) are plain
> 		if ( !proto ) {
> 			return true;
287,289c342,344
< 		// If the function hasn't returned already, we're confident that
< 		// |obj| is a plain object, created by {} or constructed with new Object
< 		return true;
---
> 		// Objects with prototype are plain iff they were constructed by a global Object function
> 		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
> 		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
293a349
> 
300,309d355
< 	type: function( obj ) {
< 		if ( obj == null ) {
< 			return obj + "";
< 		}
< 		// Support: Android<4.0, iOS<6 (functionish RegExp)
< 		return typeof obj === "object" || typeof obj === "function" ?
< 			class2type[ toString.call(obj) ] || "object" :
< 			typeof obj;
< 	},
< 
311,341c357,358
< 	globalEval: function( code ) {
< 		var script,
< 			indirect = eval;
< 
< 		code = jQuery.trim( code );
< 
< 		if ( code ) {
< 			// If the code includes a valid, prologue position
< 			// strict mode pragma, execute code by injecting a
< 			// script tag into the document.
< 			if ( code.indexOf("use strict") === 1 ) {
< 				script = document.createElement("script");
< 				script.text = code;
< 				document.head.appendChild( script ).parentNode.removeChild( script );
< 			} else {
< 			// Otherwise, avoid the DOM node creation, insertion
< 			// and removal by using an indirect global eval
< 				indirect( code );
< 			}
< 		}
< 	},
< 
< 	// Convert dashed to camelCase; used by the css and data modules
< 	// Support: IE9-11+
< 	// Microsoft forgot to hump their vendor prefix (#9572)
< 	camelCase: function( string ) {
< 		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
< 	},
< 
< 	nodeName: function( elem, name ) {
< 		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
---
> 	globalEval: function( code, options ) {
> 		DOMEval( code, { nonce: options && options.nonce } );
344,354c361,362
< 	// args is for internal usage only
< 	each: function( obj, callback, args ) {
< 		var value,
< 			i = 0,
< 			length = obj.length,
< 			isArray = isArraylike( obj );
< 
< 		if ( args ) {
< 			if ( isArray ) {
< 				for ( ; i < length; i++ ) {
< 					value = callback.apply( obj[ i ], args );
---
> 	each: function( obj, callback ) {
> 		var length, i = 0;
356,366c364,368
< 					if ( value === false ) {
< 						break;
< 					}
< 				}
< 			} else {
< 				for ( i in obj ) {
< 					value = callback.apply( obj[ i ], args );
< 
< 					if ( value === false ) {
< 						break;
< 					}
---
> 		if ( isArrayLike( obj ) ) {
> 			length = obj.length;
> 			for ( ; i < length; i++ ) {
> 				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
> 					break;
369,370d370
< 
< 		// A special, fast, case for the most common use of each
372,386c372,374
< 			if ( isArray ) {
< 				for ( ; i < length; i++ ) {
< 					value = callback.call( obj[ i ], i, obj[ i ] );
< 
< 					if ( value === false ) {
< 						break;
< 					}
< 				}
< 			} else {
< 				for ( i in obj ) {
< 					value = callback.call( obj[ i ], i, obj[ i ] );
< 
< 					if ( value === false ) {
< 						break;
< 					}
---
> 			for ( i in obj ) {
> 				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
> 					break;
394c382
< 	// Support: Android<4.1
---
> 	// Support: Android <=4.0 only
406c394
< 			if ( isArraylike( Object(arr) ) ) {
---
> 			if ( isArrayLike( Object( arr ) ) ) {
422a411,412
> 	// Support: Android <=4.0 only, PhantomJS 1 only
> 	// push.apply(_, arraylike) throws on ancient WebKit
458c448
< 		var value,
---
> 		var length, value,
460,461d449
< 			length = elems.length,
< 			isArray = isArraylike( elems ),
465c453,454
< 		if ( isArray ) {
---
> 		if ( isArrayLike( elems ) ) {
> 			length = elems.length;
492,522d480
< 	// Bind a function to a context, optionally partially applying any
< 	// arguments.
< 	proxy: function( fn, context ) {
< 		var tmp, args, proxy;
< 
< 		if ( typeof context === "string" ) {
< 			tmp = fn[ context ];
< 			context = fn;
< 			fn = tmp;
< 		}
< 
< 		// Quick check to determine if target is callable, in the spec
< 		// this throws a TypeError, but we will just return undefined.
< 		if ( !jQuery.isFunction( fn ) ) {
< 			return undefined;
< 		}
< 
< 		// Simulated bind
< 		args = slice.call( arguments, 2 );
< 		proxy = function() {
< 			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
< 		};
< 
< 		// Set the guid of unique handler to the same of original handler, so it can be removed
< 		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
< 
< 		return proxy;
< 	},
< 
< 	now: Date.now,
< 
526c484,488
< });
---
> } );
> 
> if ( typeof Symbol === "function" ) {
> 	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
> }
529c491,492
< jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
---
> jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
> function( i, name ) {
531c494
< });
---
> } );
533c496
< function isArraylike( obj ) {
---
> function isArrayLike( obj ) {
535c498
< 	// Support: iOS 8.2 (not reproducible in simulator)
---
> 	// Support: real iOS 8.2 only (not reproducible in simulator)
539,540c502,503
< 	var length = "length" in obj && obj.length,
< 		type = jQuery.type( obj );
---
> 	var length = !!obj && "length" in obj && obj.length,
> 		type = toType( obj );
542c505
< 	if ( type === "function" || jQuery.isWindow( obj ) ) {
---
> 	if ( isFunction( obj ) || isWindow( obj ) ) {
546,549d508
< 	if ( obj.nodeType === 1 && length ) {
< 		return true;
< 	}
< 
555,556c514,515
<  * Sizzle CSS Selector Engine v2.2.0-pre
<  * http://sizzlejs.com/
---
>  * Sizzle CSS Selector Engine v2.3.4
>  * https://sizzlejs.com/
558c517
<  * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
---
>  * Copyright JS Foundation and other contributors
560c519
<  * http://jquery.org/license
---
>  * https://js.foundation/
562c521
<  * Date: 2014-12-16
---
>  * Date: 2019-04-08
595a555
> 	nonnativeSelectorCache = createCache(),
603,605d562
< 	// General-purpose constants
< 	MAX_NEGATIVE = 1 << 31,
< 
614c571
< 	// http://jsperf.com/thor-indexof-vs-for/5
---
> 	// https://jsperf.com/thor-indexof-vs-for/5
630c587
< 	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
---
> 	// http://www.w3.org/TR/css3-selectors/#whitespace
632,633d588
< 	// http://www.w3.org/TR/css3-syntax/#characters
< 	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
635,638c590,591
< 	// Loosely modeled on CSS identifier characters
< 	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
< 	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
< 	identifier = characterEncoding.replace( "w", "w#" ),
---
> 	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
> 	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
641c594
< 	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
---
> 	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
648c601
< 	pseudos = ":(" + characterEncoding + ")(?:\\((" +
---
> 	pseudos = ":(" + identifier + ")(?:\\((" +
664,665c617
< 
< 	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
---
> 	rdescend = new RegExp( whitespace + "|>" ),
671,673c623,625
< 		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
< 		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
< 		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
---
> 		"ID": new RegExp( "^#(" + identifier + ")" ),
> 		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
> 		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
685a638
> 	rhtml = /HTML$/i,
695d647
< 	rescape = /'|\\/g,
697c649,650
< 	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
---
> 	// CSS escapes
> 	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
712a666,684
> 	// CSS string/identifier serialization
> 	// https://drafts.csswg.org/cssom/#common-serializing-idioms
> 	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
> 	fcssescape = function( ch, asCodePoint ) {
> 		if ( asCodePoint ) {
> 
> 			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
> 			if ( ch === "\0" ) {
> 				return "\uFFFD";
> 			}
> 
> 			// Control characters and (dependent upon position) numbers get escaped as code points
> 			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
> 		}
> 
> 		// Other potentially-special ASCII characters get backslash-escaped
> 		return "\\" + ch;
> 	},
> 
719c691,698
< 	};
---
> 	},
> 
> 	inDisabledFieldset = addCombinator(
> 		function( elem ) {
> 			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
> 		},
> 		{ dir: "parentNode", next: "legend" }
> 	);
751,753c730,731
< 	var match, elem, m, nodeType,
< 		// QSA vars
< 		i, groups, old, nid, newContext, newSelector;
---
> 	var m, i, elem, nid, match, groups, newSelector,
> 		newContext = context && context.ownerDocument,
755,757c733,734
< 	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
< 		setDocument( context );
< 	}
---
> 		// nodeType defaults to 9, since context defaults to document
> 		nodeType = context ? context.nodeType : 9;
759d735
< 	context = context || document;
761d736
< 	nodeType = context.nodeType;
762a738
> 	// Return early from calls with invalid selector or context
769c745,746
< 	if ( !seed && documentIsHTML ) {
---
> 	// Try to shortcut find operations (as opposed to filters) in HTML documents
> 	if ( !seed ) {
771,783c748,773
< 		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
< 		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
< 			// Speed-up: Sizzle("#ID")
< 			if ( (m = match[1]) ) {
< 				if ( nodeType === 9 ) {
< 					elem = context.getElementById( m );
< 					// Check parentNode to catch when Blackberry 4.6 returns
< 					// nodes that are no longer in the document (jQuery #6963)
< 					if ( elem && elem.parentNode ) {
< 						// Handle the case where IE, Opera, and Webkit return items
< 						// by name instead of ID
< 						if ( elem.id === m ) {
< 							results.push( elem );
---
> 		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
> 			setDocument( context );
> 		}
> 		context = context || document;
> 
> 		if ( documentIsHTML ) {
> 
> 			// If the selector is sufficiently simple, try using a "get*By*" DOM method
> 			// (excepting DocumentFragment context, where the methods don't exist)
> 			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
> 
> 				// ID selector
> 				if ( (m = match[1]) ) {
> 
> 					// Document context
> 					if ( nodeType === 9 ) {
> 						if ( (elem = context.getElementById( m )) ) {
> 
> 							// Support: IE, Opera, Webkit
> 							// TODO: identify versions
> 							// getElementById can match elements by name instead of ID
> 							if ( elem.id === m ) {
> 								results.push( elem );
> 								return results;
> 							}
> 						} else {
785a776,777
> 
> 					// Element context
787,794c779,789
< 						return results;
< 					}
< 				} else {
< 					// Context is not a document
< 					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
< 						contains( context, elem ) && elem.id === m ) {
< 						results.push( elem );
< 						return results;
---
> 
> 						// Support: IE, Opera, Webkit
> 						// TODO: identify versions
> 						// getElementById can match elements by name instead of ID
> 						if ( newContext && (elem = newContext.getElementById( m )) &&
> 							contains( context, elem ) &&
> 							elem.id === m ) {
> 
> 							results.push( elem );
> 							return results;
> 						}
796d790
< 				}
798,801c792,795
< 			// Speed-up: Sizzle("TAG")
< 			} else if ( match[2] ) {
< 				push.apply( results, context.getElementsByTagName( selector ) );
< 				return results;
---
> 				// Type selector
> 				} else if ( match[2] ) {
> 					push.apply( results, context.getElementsByTagName( selector ) );
> 					return results;
803,806c797,803
< 			// Speed-up: Sizzle(".CLASS")
< 			} else if ( (m = match[3]) && support.getElementsByClassName ) {
< 				push.apply( results, context.getElementsByClassName( m ) );
< 				return results;
---
> 				// Class selector
> 				} else if ( (m = match[3]) && support.getElementsByClassName &&
> 					context.getElementsByClassName ) {
> 
> 					push.apply( results, context.getElementsByClassName( m ) );
> 					return results;
> 				}
808d804
< 		}
810,821c806,830
< 		// QSA path
< 		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
< 			nid = old = expando;
< 			newContext = context;
< 			newSelector = nodeType !== 1 && selector;
< 
< 			// qSA works strangely on Element-rooted queries
< 			// We can work around this by specifying an extra ID on the root
< 			// and working up from there (Thanks to Andrew Dupont for the technique)
< 			// IE 8 doesn't work on object elements
< 			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
< 				groups = tokenize( selector );
---
> 			// Take advantage of querySelectorAll
> 			if ( support.qsa &&
> 				!nonnativeSelectorCache[ selector + " " ] &&
> 				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&
> 
> 				// Support: IE 8 only
> 				// Exclude object elements
> 				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {
> 
> 				newSelector = selector;
> 				newContext = context;
> 
> 				// qSA considers elements outside a scoping root when evaluating child or
> 				// descendant combinators, which is not what we want.
> 				// In such cases, we work around the behavior by prefixing every selector in the
> 				// list with an ID selector referencing the scope context.
> 				// Thanks to Andrew Dupont for this technique.
> 				if ( nodeType === 1 && rdescend.test( selector ) ) {
> 
> 					// Capture the context ID, setting it first if necessary
> 					if ( (nid = context.getAttribute( "id" )) ) {
> 						nid = nid.replace( rcssescape, fcssescape );
> 					} else {
> 						context.setAttribute( "id", (nid = expando) );
> 					}
823,828c832,838
< 				if ( (old = context.getAttribute("id")) ) {
< 					nid = old.replace( rescape, "\\$&" );
< 				} else {
< 					context.setAttribute( "id", nid );
< 				}
< 				nid = "[id='" + nid + "'] ";
---
> 					// Prefix every selector in the list
> 					groups = tokenize( selector );
> 					i = groups.length;
> 					while ( i-- ) {
> 						groups[i] = "#" + nid + " " + toSelector( groups[i] );
> 					}
> 					newSelector = groups.join( "," );
830,832c840,842
< 				i = groups.length;
< 				while ( i-- ) {
< 					groups[i] = nid + toSelector( groups[i] );
---
> 					// Expand context for sibling selectors
> 					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
> 						context;
834,836d843
< 				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
< 				newSelector = groups.join(",");
< 			}
838d844
< 			if ( newSelector ) {
844c850,851
< 				} catch(qsaError) {
---
> 				} catch ( qsaError ) {
> 					nonnativeSelectorCache( selector, true );
846,847c853,854
< 					if ( !old ) {
< 						context.removeAttribute("id");
---
> 					if ( nid === expando ) {
> 						context.removeAttribute( "id" );
860c867
<  * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
---
>  * @returns {function(string, object)} Returns the Object data after storing it on itself with
889c896
<  * @param {Function} fn Passed the created div and expects a boolean result
---
>  * @param {Function} fn Passed the created element and returns a boolean result
892c899
< 	var div = document.createElement("div");
---
> 	var el = document.createElement("fieldset");
895c902
< 		return !!fn( div );
---
> 		return !!fn( el );
900,901c907,908
< 		if ( div.parentNode ) {
< 			div.parentNode.removeChild( div );
---
> 		if ( el.parentNode ) {
> 			el.parentNode.removeChild( el );
904c911
< 		div = null;
---
> 		el = null;
915c922
< 		i = attrs.length;
---
> 		i = arr.length;
931,932c938
< 			( ~b.sourceIndex || MAX_NEGATIVE ) -
< 			( ~a.sourceIndex || MAX_NEGATIVE );
---
> 			a.sourceIndex - b.sourceIndex;
973a980,1035
>  * Returns a function to use in pseudos for :enabled/:disabled
>  * @param {Boolean} disabled true for :disabled; false for :enabled
>  */
> function createDisabledPseudo( disabled ) {
> 
> 	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
> 	return function( elem ) {
> 
> 		// Only certain elements can match :enabled or :disabled
> 		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
> 		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
> 		if ( "form" in elem ) {
> 
> 			// Check for inherited disabledness on relevant non-disabled elements:
> 			// * listed form-associated elements in a disabled fieldset
> 			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
> 			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
> 			// * option elements in a disabled optgroup
> 			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
> 			// All such elements have a "form" property.
> 			if ( elem.parentNode && elem.disabled === false ) {
> 
> 				// Option elements defer to a parent optgroup if present
> 				if ( "label" in elem ) {
> 					if ( "label" in elem.parentNode ) {
> 						return elem.parentNode.disabled === disabled;
> 					} else {
> 						return elem.disabled === disabled;
> 					}
> 				}
> 
> 				// Support: IE 6 - 11
> 				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
> 				return elem.isDisabled === disabled ||
> 
> 					// Where there is no isDisabled, check manually
> 					/* jshint -W018 */
> 					elem.isDisabled !== !disabled &&
> 						inDisabledFieldset( elem ) === disabled;
> 			}
> 
> 			return elem.disabled === disabled;
> 
> 		// Try to winnow out elements that can't be disabled before trusting the disabled property.
> 		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
> 		// even exist on them, let alone have a boolean value.
> 		} else if ( "label" in elem ) {
> 			return elem.disabled === disabled;
> 		}
> 
> 		// Remaining elements are neither :enabled nor :disabled
> 		return false;
> 	};
> }
> 
> /**
1013,1016c1075,1081
< 	// documentElement is verified for cases where it doesn't yet exist
< 	// (such as loading iframes in IE - #4833)
< 	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
< 	return documentElement ? documentElement.nodeName !== "HTML" : false;
---
> 	var namespace = elem.namespaceURI,
> 		docElem = (elem.ownerDocument || elem).documentElement;
> 
> 	// Support: IE <=8
> 	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
> 	// https://bugs.jquery.com/ticket/4833
> 	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
1025c1090
< 	var hasCompare, parent,
---
> 	var hasCompare, subWindow,
1028c1093
< 	// If no document and documentElement is available, return
---
> 	// Return early if doc is invalid or already selected
1033c1098
< 	// Set our document
---
> 	// Update global variables
1035,1036c1100,1101
< 	docElem = doc.documentElement;
< 	parent = doc.defaultView;
---
> 	docElem = document.documentElement;
> 	documentIsHTML = !isXML( document );
1038,1047c1103,1114
< 	// Support: IE>8
< 	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
< 	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
< 	// IE6-8 do not support the defaultView property so parent will be undefined
< 	if ( parent && parent !== parent.top ) {
< 		// IE11 does not have attachEvent, so all must suffer
< 		if ( parent.addEventListener ) {
< 			parent.addEventListener( "unload", unloadHandler, false );
< 		} else if ( parent.attachEvent ) {
< 			parent.attachEvent( "onunload", unloadHandler );
---
> 	// Support: IE 9-11, Edge
> 	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
> 	if ( preferredDoc !== document &&
> 		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
> 
> 		// Support: IE 11, Edge
> 		if ( subWindow.addEventListener ) {
> 			subWindow.addEventListener( "unload", unloadHandler, false );
> 
> 		// Support: IE 9 - 10 only
> 		} else if ( subWindow.attachEvent ) {
> 			subWindow.attachEvent( "onunload", unloadHandler );
1051,1054d1117
< 	/* Support tests
< 	---------------------------------------------------------------------- */
< 	documentIsHTML = !isXML( doc );
< 
1061,1063c1124,1126
< 	support.attributes = assert(function( div ) {
< 		div.className = "i";
< 		return !div.getAttribute("className");
---
> 	support.attributes = assert(function( el ) {
> 		el.className = "i";
> 		return !el.getAttribute("className");
1070,1072c1133,1135
< 	support.getElementsByTagName = assert(function( div ) {
< 		div.appendChild( doc.createComment("") );
< 		return !div.getElementsByTagName("*").length;
---
> 	support.getElementsByTagName = assert(function( el ) {
> 		el.appendChild( document.createComment("") );
> 		return !el.getElementsByTagName("*").length;
1076c1139
< 	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );
---
> 	support.getElementsByClassName = rnative.test( document.getElementsByClassName );
1080c1143
< 	// The broken getElementById methods don't pick up programatically-set names,
---
> 	// The broken getElementById methods don't pick up programmatically-set names,
1082,1084c1145,1147
< 	support.getById = assert(function( div ) {
< 		docElem.appendChild( div ).id = expando;
< 		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
---
> 	support.getById = assert(function( el ) {
> 		docElem.appendChild( el ).id = expando;
> 		return !document.getElementsByName || !document.getElementsByName( expando ).length;
1087c1150
< 	// ID find and filter
---
> 	// ID filter and find
1089,1096d1151
< 		Expr.find["ID"] = function( id, context ) {
< 			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
< 				var m = context.getElementById( id );
< 				// Check parentNode to catch when Blackberry 4.6 returns
< 				// nodes that are no longer in the document #6963
< 				return m && m.parentNode ? [ m ] : [];
< 			}
< 		};
1102a1158,1163
> 		Expr.find["ID"] = function( id, context ) {
> 			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
> 				var elem = context.getElementById( id );
> 				return elem ? [ elem ] : [];
> 			}
> 		};
1104,1107d1164
< 		// Support: IE6/7
< 		// getElementById is not reliable as a find shortcut
< 		delete Expr.find["ID"];
< 
1111c1168,1169
< 				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
---
> 				var node = typeof elem.getAttributeNode !== "undefined" &&
> 					elem.getAttributeNode("id");
1114a1173,1202
> 
> 		// Support: IE 6 - 7 only
> 		// getElementById is not reliable as a find shortcut
> 		Expr.find["ID"] = function( id, context ) {
> 			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
> 				var node, i, elems,
> 					elem = context.getElementById( id );
> 
> 				if ( elem ) {
> 
> 					// Verify the id attribute
> 					node = elem.getAttributeNode("id");
> 					if ( node && node.value === id ) {
> 						return [ elem ];
> 					}
> 
> 					// Fall back on getElementsByName
> 					elems = context.getElementsByName( id );
> 					i = 0;
> 					while ( (elem = elems[i++]) ) {
> 						node = elem.getAttributeNode("id");
> 						if ( node && node.value === id ) {
> 							return [ elem ];
> 						}
> 					}
> 				}
> 
> 				return [];
> 			}
> 		};
1151c1239
< 		if ( documentIsHTML ) {
---
> 		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
1168c1256
< 	// See http://bugs.jquery.com/ticket/13378
---
> 	// See https://bugs.jquery.com/ticket/13378
1171c1259
< 	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
---
> 	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
1174c1262
< 		assert(function( div ) {
---
> 		assert(function( el ) {
1179,1181c1267,1269
< 			// http://bugs.jquery.com/ticket/12359
< 			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
< 				"<select id='" + expando + "-\f]' msallowcapture=''>" +
---
> 			// https://bugs.jquery.com/ticket/12359
> 			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
> 				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
1187,1188c1275,1276
< 			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
< 			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
---
> 			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
> 			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
1194c1282
< 			if ( !div.querySelectorAll("[selected]").length ) {
---
> 			if ( !el.querySelectorAll("[selected]").length ) {
1198,1199c1286,1287
< 			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
< 			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
---
> 			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
> 			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
1206c1294
< 			if ( !div.querySelectorAll(":checked").length ) {
---
> 			if ( !el.querySelectorAll(":checked").length ) {
1212,1213c1300,1301
< 			// In-page `selector#id sibing-combinator selector` fails
< 			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
---
> 			// In-page `selector#id sibling-combinator selector` fails
> 			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
1218c1306,1309
< 		assert(function( div ) {
---
> 		assert(function( el ) {
> 			el.innerHTML = "<a href='' disabled='disabled'></a>" +
> 				"<select disabled='disabled'><option/></select>";
> 
1221c1312
< 			var input = doc.createElement("input");
---
> 			var input = document.createElement("input");
1223c1314
< 			div.appendChild( input ).setAttribute( "name", "D" );
---
> 			el.appendChild( input ).setAttribute( "name", "D" );
1227c1318
< 			if ( div.querySelectorAll("[name=d]").length ) {
---
> 			if ( el.querySelectorAll("[name=d]").length ) {
1233c1324,1331
< 			if ( !div.querySelectorAll(":enabled").length ) {
---
> 			if ( el.querySelectorAll(":enabled").length !== 2 ) {
> 				rbuggyQSA.push( ":enabled", ":disabled" );
> 			}
> 
> 			// Support: IE9-11+
> 			// IE's :disabled selector does not pick up the children of disabled fieldsets
> 			docElem.appendChild( el ).disabled = true;
> 			if ( el.querySelectorAll(":disabled").length !== 2 ) {
1238c1336
< 			div.querySelectorAll("*,:x");
---
> 			el.querySelectorAll("*,:x");
1249c1347
< 		assert(function( div ) {
---
> 		assert(function( el ) {
1252c1350
< 			support.disconnectedMatch = matches.call( div, "div" );
---
> 			support.disconnectedMatch = matches.call( el, "*" );
1256c1354
< 			matches.call( div, "[s!='']:x" );
---
> 			matches.call( el, "[s!='']:x" );
1269c1367
< 	// Purposefully does not implement inclusive descendent
---
> 	// Purposefully self-exclusive
1323c1421
< 			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
---
> 			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
1326c1424
< 			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
---
> 			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
1354,1355c1452,1453
< 			return a === doc ? -1 :
< 				b === doc ? 1 :
---
> 			return a === document ? -1 :
> 				b === document ? 1 :
1392c1490
< 	return doc;
---
> 	return document;
1405,1407d1502
< 	// Make sure that attribute selectors are quoted
< 	expr = expr.replace( rattributeQuotes, "='$1']" );
< 
1408a1504
> 		!nonnativeSelectorCache[ expr + " " ] &&
1422c1518,1520
< 		} catch (e) {}
---
> 		} catch (e) {
> 			nonnativeSelectorCache( expr, true );
> 		}
1456a1555,1558
> Sizzle.escape = function( sel ) {
> 	return (sel + "").replace( rcssescape, fcssescape );
> };
> 
1682c1784
< 					var cache, outerCache, node, diff, nodeIndex, start,
---
> 					var cache, uniqueCache, outerCache, node, nodeIndex, start,
1686c1788,1789
< 						useCache = !xml && !ofType;
---
> 						useCache = !xml && !ofType,
> 						diff = false;
1695c1798,1801
< 									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
---
> 									if ( ofType ?
> 										node.nodeName.toLowerCase() === name :
> 										node.nodeType === 1 ) {
> 
1708a1815
> 
1710,1713c1817,1829
< 							outerCache = parent[ expando ] || (parent[ expando ] = {});
< 							cache = outerCache[ type ] || [];
< 							nodeIndex = cache[0] === dirruns && cache[1];
< 							diff = cache[0] === dirruns && cache[2];
---
> 
> 							// ...in a gzip-friendly way
> 							node = parent;
> 							outerCache = node[ expando ] || (node[ expando ] = {});
> 
> 							// Support: IE <9 only
> 							// Defend against cloned attroperties (jQuery gh-1709)
> 							uniqueCache = outerCache[ node.uniqueID ] ||
> 								(outerCache[ node.uniqueID ] = {});
> 
> 							cache = uniqueCache[ type ] || [];
> 							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
> 							diff = nodeIndex && cache[ 2 ];
1723c1839
< 									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
---
> 									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
1728,1732d1843
< 						// Use previously-cached element index if available
< 						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
< 							diff = cache[1];
< 
< 						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
1734,1736c1845,1849
< 							// Use the same loop as above to seek `elem` from the start
< 							while ( (node = ++nodeIndex && node && node[ dir ] ||
< 								(diff = nodeIndex = 0) || start.pop()) ) {
---
> 							// Use previously-cached element index if available
> 							if ( useCache ) {
> 								// ...in a gzip-friendly way
> 								node = elem;
> 								outerCache = node[ expando ] || (node[ expando ] = {});
1738,1742c1851,1859
< 								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
< 									// Cache the index of each encountered element
< 									if ( useCache ) {
< 										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
< 									}
---
> 								// Support: IE <9 only
> 								// Defend against cloned attroperties (jQuery gh-1709)
> 								uniqueCache = outerCache[ node.uniqueID ] ||
> 									(outerCache[ node.uniqueID ] = {});
> 
> 								cache = uniqueCache[ type ] || [];
> 								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
> 								diff = nodeIndex;
> 							}
1744,1745c1861,1887
< 									if ( node === elem ) {
< 										break;
---
> 							// xml :nth-child(...)
> 							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
> 							if ( diff === false ) {
> 								// Use the same loop as above to seek `elem` from the start
> 								while ( (node = ++nodeIndex && node && node[ dir ] ||
> 									(diff = nodeIndex = 0) || start.pop()) ) {
> 
> 									if ( ( ofType ?
> 										node.nodeName.toLowerCase() === name :
> 										node.nodeType === 1 ) &&
> 										++diff ) {
> 
> 										// Cache the index of each encountered element
> 										if ( useCache ) {
> 											outerCache = node[ expando ] || (node[ expando ] = {});
> 
> 											// Support: IE <9 only
> 											// Defend against cloned attroperties (jQuery gh-1709)
> 											uniqueCache = outerCache[ node.uniqueID ] ||
> 												(outerCache[ node.uniqueID ] = {});
> 
> 											uniqueCache[ type ] = [ dirruns, diff ];
> 										}
> 
> 										if ( node === elem ) {
> 											break;
> 										}
1837c1979
< 				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
---
> 				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
1884,1890c2026,2027
< 		"enabled": function( elem ) {
< 			return elem.disabled === false;
< 		},
< 
< 		"disabled": function( elem ) {
< 			return elem.disabled === true;
< 		},
---
> 		"enabled": createDisabledPseudo( false ),
> 		"disabled": createDisabledPseudo( true ),
1981c2118,2122
< 			var i = argument < 0 ? argument + length : argument;
---
> 			var i = argument < 0 ?
> 				argument + length :
> 				argument > length ?
> 					length :
> 					argument;
2092c2233,2235
< 		checkNonElements = base && dir === "parentNode",
---
> 		skip = combinator.next,
> 		key = skip || dir,
> 		checkNonElements = base && key === "parentNode",
2102a2246
> 			return false;
2107c2251
< 			var oldCache, outerCache,
---
> 			var oldCache, uniqueCache, outerCache,
2110c2254
< 			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
---
> 			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
2123c2267,2274
< 						if ( (oldCache = outerCache[ dir ]) &&
---
> 
> 						// Support: IE <9 only
> 						// Defend against cloned attroperties (jQuery gh-1709)
> 						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
> 
> 						if ( skip && skip === elem.nodeName.toLowerCase() ) {
> 							elem = elem[ dir ] || elem;
> 						} else if ( (oldCache = uniqueCache[ key ]) &&
2130c2281
< 							outerCache[ dir ] = newCache;
---
> 							uniqueCache[ key ] = newCache;
2139a2291
> 			return false;
2355c2507
< 				outermostContext = context !== document && context;
---
> 				outermostContext = context === document || context || outermost;
2359d2510
< 			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
2364a2516,2519
> 					if ( !context && elem.ownerDocument !== document ) {
> 						setDocument( elem );
> 						xml = !documentIsHTML;
> 					}
2366c2521
< 						if ( matcher( elem, context, xml ) ) {
---
> 						if ( matcher( elem, context || document, xml) ) {
2390c2545,2546
< 			// Apply set filters to unmatched elements
---
> 			// `i` is now the count of elements visited above, and adding it to `matchedCount`
> 			// makes the latter nonnegative.
2391a2548,2555
> 
> 			// Apply set filters to unmatched elements
> 			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
> 			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
> 			// no element matchers and no seed.
> 			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
> 			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
> 			// numerically zero.
2483c2647,2648
< 	// Try to minimize operations if there is no seed and only one group
---
> 	// Try to minimize operations if there is only one selector in the list and no seed
> 	// (the latter of which guarantees us context)
2486c2651
< 		// Take a shortcut and set the context if the root selector is an ID
---
> 		// Reduce context if the leading compound selector is an ID
2489,2490c2654
< 				support.getById && context.nodeType === 9 && documentIsHTML &&
< 				Expr.relative[ tokens[1].type ] ) {
---
> 				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {
2541c2705
< 		rsibling.test( selector ) && testContext( context.parentNode ) || context
---
> 		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
2560c2724
< support.sortDetached = assert(function( div1 ) {
---
> support.sortDetached = assert(function( el ) {
2562c2726
< 	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
---
> 	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
2567,2570c2731,2734
< // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
< if ( !assert(function( div ) {
< 	div.innerHTML = "<a href='#'></a>";
< 	return div.firstChild.getAttribute("href") === "#" ;
---
> // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
> if ( !assert(function( el ) {
> 	el.innerHTML = "<a href='#'></a>";
> 	return el.firstChild.getAttribute("href") === "#" ;
2581,2584c2745,2748
< if ( !support.attributes || !assert(function( div ) {
< 	div.innerHTML = "<input/>";
< 	div.firstChild.setAttribute( "value", "" );
< 	return div.firstChild.getAttribute( "value" ) === "";
---
> if ( !support.attributes || !assert(function( el ) {
> 	el.innerHTML = "<input/>";
> 	el.firstChild.setAttribute( "value", "" );
> 	return el.firstChild.getAttribute( "value" ) === "";
2595,2596c2759,2760
< if ( !assert(function( div ) {
< 	return div.getAttribute("disabled") == null;
---
> if ( !assert(function( el ) {
> 	return el.getAttribute("disabled") == null;
2617,2618c2781,2784
< jQuery.expr[":"] = jQuery.expr.pseudos;
< jQuery.unique = Sizzle.uniqueSort;
---
> 
> // Deprecated
> jQuery.expr[ ":" ] = jQuery.expr.pseudos;
> jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
2621a2788,2810
> jQuery.escapeSelector = Sizzle.escape;
> 
> 
> 
> 
> var dir = function( elem, dir, until ) {
> 	var matched = [],
> 		truncate = until !== undefined;
> 
> 	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
> 		if ( elem.nodeType === 1 ) {
> 			if ( truncate && jQuery( elem ).is( until ) ) {
> 				break;
> 			}
> 			matched.push( elem );
> 		}
> 	}
> 	return matched;
> };
> 
> 
> var siblings = function( n, elem ) {
> 	var matched = [];
2622a2812,2819
> 	for ( ; n; n = n.nextSibling ) {
> 		if ( n.nodeType === 1 && n !== elem ) {
> 			matched.push( n );
> 		}
> 	}
> 
> 	return matched;
> };
2627d2823
< var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
2629a2826,2832
> function nodeName( elem, name ) {
> 
>   return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
> 
> };
> var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
> 
2631d2833
< var risSimple = /^.[^:#\[\.,]*$/;
2635c2837
< 	if ( jQuery.isFunction( qualifier ) ) {
---
> 	if ( isFunction( qualifier ) ) {
2637d2838
< 			/* jshint -W018 */
2639,2640c2840
< 		});
< 
---
> 		} );
2642a2843
> 	// Single element
2646,2647c2847
< 		});
< 
---
> 		} );
2650,2655c2850,2854
< 	if ( typeof qualifier === "string" ) {
< 		if ( risSimple.test( qualifier ) ) {
< 			return jQuery.filter( qualifier, elements, not );
< 		}
< 
< 		qualifier = jQuery.filter( qualifier, elements );
---
> 	// Arraylike of elements (jQuery, arguments, Array)
> 	if ( typeof qualifier !== "string" ) {
> 		return jQuery.grep( elements, function( elem ) {
> 			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
> 		} );
2658,2660c2857,2858
< 	return jQuery.grep( elements, function( elem ) {
< 		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
< 	});
---
> 	// Filtered directly for both simple and complex selectors
> 	return jQuery.filter( qualifier, elements, not );
2670,2674c2868,2874
< 	return elems.length === 1 && elem.nodeType === 1 ?
< 		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
< 		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
< 			return elem.nodeType === 1;
< 		}));
---
> 	if ( elems.length === 1 && elem.nodeType === 1 ) {
> 		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
> 	}
> 
> 	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
> 		return elem.nodeType === 1;
> 	} ) );
2677c2877
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
2679c2879
< 		var i,
---
> 		var i, ret,
2681d2880
< 			ret = [],
2685c2884
< 			return this.pushStack( jQuery( selector ).filter(function() {
---
> 			return this.pushStack( jQuery( selector ).filter( function() {
2691c2890
< 			}) );
---
> 			} ) );
2693a2893,2894
> 		ret = this.pushStack( [] );
> 
2698,2701c2899
< 		// Needed because $( selector, context ) becomes $( context ).find( selector )
< 		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
< 		ret.selector = this.selector ? this.selector + " " + selector : selector;
< 		return ret;
---
> 		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
2704c2902
< 		return this.pushStack( winnow(this, selector || [], false) );
---
> 		return this.pushStack( winnow( this, selector || [], false ) );
2707c2905
< 		return this.pushStack( winnow(this, selector || [], true) );
---
> 		return this.pushStack( winnow( this, selector || [], true ) );
2721c2919
< });
---
> } );
2733c2931,2932
< 	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
---
> 	// Shortcut simple #id case for speed
> 	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
2735c2934
< 	init = jQuery.fn.init = function( selector, context ) {
---
> 	init = jQuery.fn.init = function( selector, context, root ) {
2742a2942,2945
> 		// Method init() accepts an alternate rootjQuery
> 		// so migrate can support jQuery.sub (gh-2101)
> 		root = root || rootjQuery;
> 
2745c2948,2951
< 			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
---
> 			if ( selector[ 0 ] === "<" &&
> 				selector[ selector.length - 1 ] === ">" &&
> 				selector.length >= 3 ) {
> 
2754c2960
< 			if ( match && (match[1] || !context) ) {
---
> 			if ( match && ( match[ 1 ] || !context ) ) {
2757,2758c2963,2964
< 				if ( match[1] ) {
< 					context = context instanceof jQuery ? context[0] : context;
---
> 				if ( match[ 1 ] ) {
> 					context = context instanceof jQuery ? context[ 0 ] : context;
2763c2969
< 						match[1],
---
> 						match[ 1 ],
2769c2975
< 					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
---
> 					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
2770a2977
> 
2772c2979
< 							if ( jQuery.isFunction( this[ match ] ) ) {
---
> 							if ( isFunction( this[ match ] ) ) {
2786c2993,2995
< 					elem = document.getElementById( match[2] );
---
> 					elem = document.getElementById( match[ 2 ] );
> 
> 					if ( elem ) {
2788,2790d2996
< 					// Support: Blackberry 4.6
< 					// gEBID returns nodes no longer in the document (#6963)
< 					if ( elem && elem.parentNode ) {
2791a2998
> 						this[ 0 ] = elem;
2793d2999
< 						this[0] = elem;
2795,2797d3000
< 
< 					this.context = document;
< 					this.selector = selector;
2803c3006
< 				return ( context || rootjQuery ).find( selector );
---
> 				return ( context || root ).find( selector );
2813c3016
< 			this.context = this[0] = selector;
---
> 			this[ 0 ] = selector;
2819,2821c3022,3025
< 		} else if ( jQuery.isFunction( selector ) ) {
< 			return typeof rootjQuery.ready !== "undefined" ?
< 				rootjQuery.ready( selector ) :
---
> 		} else if ( isFunction( selector ) ) {
> 			return root.ready !== undefined ?
> 				root.ready( selector ) :
> 
2826,2830d3029
< 		if ( selector.selector !== undefined ) {
< 			this.selector = selector.selector;
< 			this.context = selector.context;
< 		}
< 
2841a3041
> 
2850,2879c3050
< jQuery.extend({
< 	dir: function( elem, dir, until ) {
< 		var matched = [],
< 			truncate = until !== undefined;
< 
< 		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
< 			if ( elem.nodeType === 1 ) {
< 				if ( truncate && jQuery( elem ).is( until ) ) {
< 					break;
< 				}
< 				matched.push( elem );
< 			}
< 		}
< 		return matched;
< 	},
< 
< 	sibling: function( n, elem ) {
< 		var matched = [];
< 
< 		for ( ; n; n = n.nextSibling ) {
< 			if ( n.nodeType === 1 && n !== elem ) {
< 				matched.push( n );
< 			}
< 		}
< 
< 		return matched;
< 	}
< });
< 
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
2884c3055
< 		return this.filter(function() {
---
> 		return this.filter( function() {
2887c3058
< 				if ( jQuery.contains( this, targets[i] ) ) {
---
> 				if ( jQuery.contains( this, targets[ i ] ) ) {
2891c3062
< 		});
---
> 		} );
2899,2901c3070
< 			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
< 				jQuery( selectors, context || this.context ) :
< 				0;
---
> 			targets = typeof selectors !== "string" && jQuery( selectors );
2903,2911c3072,3075
< 		for ( ; i < l; i++ ) {
< 			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
< 				// Always skip document fragments
< 				if ( cur.nodeType < 11 && (pos ?
< 					pos.index(cur) > -1 :
< 
< 					// Don't pass non-elements to Sizzle
< 					cur.nodeType === 1 &&
< 						jQuery.find.matchesSelector(cur, selectors)) ) {
---
> 		// Positional selectors never match, since there's no _selection_ context
> 		if ( !rneedsContext.test( selectors ) ) {
> 			for ( ; i < l; i++ ) {
> 				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
2913,2914c3077,3087
< 					matched.push( cur );
< 					break;
---
> 					// Always skip document fragments
> 					if ( cur.nodeType < 11 && ( targets ?
> 						targets.index( cur ) > -1 :
> 
> 						// Don't pass non-elements to Sizzle
> 						cur.nodeType === 1 &&
> 							jQuery.find.matchesSelector( cur, selectors ) ) ) {
> 
> 						matched.push( cur );
> 						break;
> 					}
2919c3092
< 		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
---
> 		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
2945c3118
< 			jQuery.unique(
---
> 			jQuery.uniqueSort(
2953c3126
< 			this.prevObject : this.prevObject.filter(selector)
---
> 			this.prevObject : this.prevObject.filter( selector )
2956c3129
< });
---
> } );
2959c3132
< 	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
---
> 	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
2963c3136
< jQuery.each({
---
> jQuery.each( {
2969c3142
< 		return jQuery.dir( elem, "parentNode" );
---
> 		return dir( elem, "parentNode" );
2972c3145
< 		return jQuery.dir( elem, "parentNode", until );
---
> 		return dir( elem, "parentNode", until );
2981c3154
< 		return jQuery.dir( elem, "nextSibling" );
---
> 		return dir( elem, "nextSibling" );
2984c3157
< 		return jQuery.dir( elem, "previousSibling" );
---
> 		return dir( elem, "previousSibling" );
2987c3160
< 		return jQuery.dir( elem, "nextSibling", until );
---
> 		return dir( elem, "nextSibling", until );
2990c3163
< 		return jQuery.dir( elem, "previousSibling", until );
---
> 		return dir( elem, "previousSibling", until );
2993c3166
< 		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
---
> 		return siblings( ( elem.parentNode || {} ).firstChild, elem );
2996c3169
< 		return jQuery.sibling( elem.firstChild );
---
> 		return siblings( elem.firstChild );
2999c3172,3183
< 		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
---
> 		if ( typeof elem.contentDocument !== "undefined" ) {
> 			return elem.contentDocument;
> 		}
> 
> 		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
> 		// Treat the template element as a regular one in browsers that
> 		// don't support it.
> 		if ( nodeName( elem, "template" ) ) {
> 			elem = elem.content || elem;
> 		}
> 
> 		return jQuery.merge( [], elem.childNodes );
3013a3198
> 
3016c3201
< 				jQuery.unique( matched );
---
> 				jQuery.uniqueSort( matched );
3027,3028c3212,3213
< });
< var rnotwhite = (/\S+/g);
---
> } );
> var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
3032,3035c3217
< // String to Object options format cache
< var optionsCache = {};
< 
< // Convert String-formatted options into Object-formatted ones and store in cache
---
> // Convert String-formatted options into Object-formatted ones
3037,3038c3219,3220
< 	var object = optionsCache[ options ] = {};
< 	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
---
> 	var object = {};
> 	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
3040c3222
< 	});
---
> 	} );
3071c3253
< 		( optionsCache[ options ] || createOptions( options ) ) :
---
> 		createOptions( options ) :
3074c3256,3259
< 	var // Last fire value (for non-forgettable lists)
---
> 	var // Flag to know if list is currently firing
> 		firing,
> 
> 		// Last fire value for non-forgettable lists
3075a3261
> 
3078,3085c3264,3267
< 		// Flag to know if list is currently firing
< 		firing,
< 		// First callback to fire (used internally by add and fireWith)
< 		firingStart,
< 		// End of the loop when firing
< 		firingLength,
< 		// Index of currently firing callback (modified by remove if needed)
< 		firingIndex,
---
> 
> 		// Flag to prevent firing
> 		locked,
> 
3088,3089c3270,3276
< 		// Stack of fire calls for repeatable lists
< 		stack = !options.once && [],
---
> 
> 		// Queue of execution data for repeatable lists
> 		queue = [],
> 
> 		// Index of currently firing callback (modified by add/remove as needed)
> 		firingIndex = -1,
> 
3091,3101c3278,3297
< 		fire = function( data ) {
< 			memory = options.memory && data;
< 			fired = true;
< 			firingIndex = firingStart || 0;
< 			firingStart = 0;
< 			firingLength = list.length;
< 			firing = true;
< 			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
< 				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
< 					memory = false; // To prevent further calls using add
< 					break;
---
> 		fire = function() {
> 
> 			// Enforce single-firing
> 			locked = locked || options.once;
> 
> 			// Execute callbacks for all pending executions,
> 			// respecting firingIndex overrides and runtime changes
> 			fired = firing = true;
> 			for ( ; queue.length; firingIndex = -1 ) {
> 				memory = queue.shift();
> 				while ( ++firingIndex < list.length ) {
> 
> 					// Run callback and check for early termination
> 					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
> 						options.stopOnFalse ) {
> 
> 						// Jump to end and forget the data so .add doesn't re-fire
> 						firingIndex = list.length;
> 						memory = false;
> 					}
3103a3300,3305
> 
> 			// Forget the data if we're done with it
> 			if ( !options.memory ) {
> 				memory = false;
> 			}
> 
3105,3110c3307,3312
< 			if ( list ) {
< 				if ( stack ) {
< 					if ( stack.length ) {
< 						fire( stack.shift() );
< 					}
< 				} else if ( memory ) {
---
> 
> 			// Clean up if we're done firing for good
> 			if ( locked ) {
> 
> 				// Keep an empty list if we have data for future add calls
> 				if ( memory ) {
3111a3314,3315
> 
> 				// Otherwise, this object is spent
3113c3317
< 					self.disable();
---
> 					list = "";
3116a3321
> 
3118a3324
> 
3122,3124c3328,3335
< 					// First, we save the current length
< 					var start = list.length;
< 					(function add( args ) {
---
> 
> 					// If we have memory from a past run, we should fire after adding
> 					if ( memory && !firing ) {
> 						firingIndex = list.length - 1;
> 						queue.push( memory );
> 					}
> 
> 					( function add( args ) {
3126,3127c3337
< 							var type = jQuery.type( arg );
< 							if ( type === "function" ) {
---
> 							if ( isFunction( arg ) ) {
3131c3341,3342
< 							} else if ( arg && arg.length && type !== "string" ) {
---
> 							} else if ( arg && arg.length && toType( arg ) !== "string" ) {
> 
3135,3145c3346,3350
< 						});
< 					})( arguments );
< 					// Do we need to add the callbacks to the
< 					// current firing batch?
< 					if ( firing ) {
< 						firingLength = list.length;
< 					// With memory, if we're not firing then
< 					// we should call right away
< 					} else if ( memory ) {
< 						firingStart = start;
< 						fire( memory );
---
> 						} );
> 					} )( arguments );
> 
> 					if ( memory && !firing ) {
> 						fire();
3149a3355
> 
3152,3165c3358,3365
< 				if ( list ) {
< 					jQuery.each( arguments, function( _, arg ) {
< 						var index;
< 						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
< 							list.splice( index, 1 );
< 							// Handle firing indexes
< 							if ( firing ) {
< 								if ( index <= firingLength ) {
< 									firingLength--;
< 								}
< 								if ( index <= firingIndex ) {
< 									firingIndex--;
< 								}
< 							}
---
> 				jQuery.each( arguments, function( _, arg ) {
> 					var index;
> 					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
> 						list.splice( index, 1 );
> 
> 						// Handle firing indexes
> 						if ( index <= firingIndex ) {
> 							firingIndex--;
3167,3168c3367,3368
< 					});
< 				}
---
> 					}
> 				} );
3170a3371
> 
3174c3375,3377
< 				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
---
> 				return fn ?
> 					jQuery.inArray( fn, list ) > -1 :
> 					list.length > 0;
3175a3379
> 
3178,3179c3382,3384
< 				list = [];
< 				firingLength = 0;
---
> 				if ( list ) {
> 					list = [];
> 				}
3182c3387,3390
< 			// Have the list do nothing anymore
---
> 
> 			// Disable .fire and .add
> 			// Abort any current/pending executions
> 			// Clear all callbacks and values
3184c3392,3393
< 				list = stack = memory = undefined;
---
> 				locked = queue = [];
> 				list = memory = "";
3187d3395
< 			// Is it disabled?
3191c3399,3402
< 			// Lock the list in its current state
---
> 
> 			// Disable .fire
> 			// Also disable .add unless we have memory (since it would have no effect)
> 			// Abort any pending executions
3193,3195c3404,3406
< 				stack = undefined;
< 				if ( !memory ) {
< 					self.disable();
---
> 				locked = queue = [];
> 				if ( !memory && !firing ) {
> 					list = memory = "";
3199d3409
< 			// Is it locked?
3201c3411
< 				return !stack;
---
> 				return !!locked;
3202a3413
> 
3205c3416
< 				if ( list && ( !fired || stack ) ) {
---
> 				if ( !locked ) {
3208,3211c3419,3421
< 					if ( firing ) {
< 						stack.push( args );
< 					} else {
< 						fire( args );
---
> 					queue.push( args );
> 					if ( !firing ) {
> 						fire();
3215a3426
> 
3220a3432
> 
3231c3443,3483
< jQuery.extend({
---
> function Identity( v ) {
> 	return v;
> }
> function Thrower( ex ) {
> 	throw ex;
> }
> 
> function adoptValue( value, resolve, reject, noValue ) {
> 	var method;
> 
> 	try {
> 
> 		// Check for promise aspect first to privilege synchronous behavior
> 		if ( value && isFunction( ( method = value.promise ) ) ) {
> 			method.call( value ).done( resolve ).fail( reject );
> 
> 		// Other thenables
> 		} else if ( value && isFunction( ( method = value.then ) ) ) {
> 			method.call( value, resolve, reject );
> 
> 		// Other non-thenables
> 		} else {
> 
> 			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
> 			// * false: [ value ].slice( 0 ) => resolve( value )
> 			// * true: [ value ].slice( 1 ) => resolve()
> 			resolve.apply( undefined, [ value ].slice( noValue ) );
> 		}
> 
> 	// For Promises/A+, convert exceptions into rejections
> 	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
> 	// Deferred#then to conditionally suppress rejection.
> 	} catch ( value ) {
> 
> 		// Support: Android 4.0 only
> 		// Strict mode functions invoked without .call/.apply get global-object context
> 		reject.apply( undefined, [ value ] );
> 	}
> }
> 
> jQuery.extend( {
3235,3238c3487,3495
< 				// action, add listener, listener list, final state
< 				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
< 				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
< 				[ "notify", "progress", jQuery.Callbacks("memory") ]
---
> 
> 				// action, add listener, callbacks,
> 				// ... .then handlers, argument index, [final state]
> 				[ "notify", "progress", jQuery.Callbacks( "memory" ),
> 					jQuery.Callbacks( "memory" ), 2 ],
> 				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
> 					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
> 				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
> 					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
3249c3506,3511
< 				then: function( /* fnDone, fnFail, fnProgress */ ) {
---
> 				"catch": function( fn ) {
> 					return promise.then( null, fn );
> 				},
> 
> 				// Keep pipe for back-compat
> 				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
3251c3513,3514
< 					return jQuery.Deferred(function( newDefer ) {
---
> 
> 					return jQuery.Deferred( function( newDefer ) {
3253,3255c3516,3523
< 							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
< 							// deferred[ done | fail | progress ] for forwarding actions to newDefer
< 							deferred[ tuple[1] ](function() {
---
> 
> 							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
> 							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
> 
> 							// deferred.progress(function() { bind to newDefer or newDefer.notify })
> 							// deferred.done(function() { bind to newDefer or newDefer.resolve })
> 							// deferred.fail(function() { bind to newDefer or newDefer.reject })
> 							deferred[ tuple[ 1 ] ]( function() {
3257c3525
< 								if ( returned && jQuery.isFunction( returned.promise ) ) {
---
> 								if ( returned && isFunction( returned.promise ) ) {
3258a3527
> 										.progress( newDefer.notify )
3260,3261c3529
< 										.fail( newDefer.reject )
< 										.progress( newDefer.notify );
---
> 										.fail( newDefer.reject );
3263c3531,3534
< 									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
---
> 									newDefer[ tuple[ 0 ] + "With" ](
> 										this,
> 										fn ? [ returned ] : arguments
> 									);
3265,3266c3536,3537
< 							});
< 						});
---
> 							} );
> 						} );
3268c3539,3703
< 					}).promise();
---
> 					} ).promise();
> 				},
> 				then: function( onFulfilled, onRejected, onProgress ) {
> 					var maxDepth = 0;
> 					function resolve( depth, deferred, handler, special ) {
> 						return function() {
> 							var that = this,
> 								args = arguments,
> 								mightThrow = function() {
> 									var returned, then;
> 
> 									// Support: Promises/A+ section 2.3.3.3.3
> 									// https://promisesaplus.com/#point-59
> 									// Ignore double-resolution attempts
> 									if ( depth < maxDepth ) {
> 										return;
> 									}
> 
> 									returned = handler.apply( that, args );
> 
> 									// Support: Promises/A+ section 2.3.1
> 									// https://promisesaplus.com/#point-48
> 									if ( returned === deferred.promise() ) {
> 										throw new TypeError( "Thenable self-resolution" );
> 									}
> 
> 									// Support: Promises/A+ sections 2.3.3.1, 3.5
> 									// https://promisesaplus.com/#point-54
> 									// https://promisesaplus.com/#point-75
> 									// Retrieve `then` only once
> 									then = returned &&
> 
> 										// Support: Promises/A+ section 2.3.4
> 										// https://promisesaplus.com/#point-64
> 										// Only check objects and functions for thenability
> 										( typeof returned === "object" ||
> 											typeof returned === "function" ) &&
> 										returned.then;
> 
> 									// Handle a returned thenable
> 									if ( isFunction( then ) ) {
> 
> 										// Special processors (notify) just wait for resolution
> 										if ( special ) {
> 											then.call(
> 												returned,
> 												resolve( maxDepth, deferred, Identity, special ),
> 												resolve( maxDepth, deferred, Thrower, special )
> 											);
> 
> 										// Normal processors (resolve) also hook into progress
> 										} else {
> 
> 											// ...and disregard older resolution values
> 											maxDepth++;
> 
> 											then.call(
> 												returned,
> 												resolve( maxDepth, deferred, Identity, special ),
> 												resolve( maxDepth, deferred, Thrower, special ),
> 												resolve( maxDepth, deferred, Identity,
> 													deferred.notifyWith )
> 											);
> 										}
> 
> 									// Handle all other returned values
> 									} else {
> 
> 										// Only substitute handlers pass on context
> 										// and multiple values (non-spec behavior)
> 										if ( handler !== Identity ) {
> 											that = undefined;
> 											args = [ returned ];
> 										}
> 
> 										// Process the value(s)
> 										// Default process is resolve
> 										( special || deferred.resolveWith )( that, args );
> 									}
> 								},
> 
> 								// Only normal processors (resolve) catch and reject exceptions
> 								process = special ?
> 									mightThrow :
> 									function() {
> 										try {
> 											mightThrow();
> 										} catch ( e ) {
> 
> 											if ( jQuery.Deferred.exceptionHook ) {
> 												jQuery.Deferred.exceptionHook( e,
> 													process.stackTrace );
> 											}
> 
> 											// Support: Promises/A+ section 2.3.3.3.4.1
> 											// https://promisesaplus.com/#point-61
> 											// Ignore post-resolution exceptions
> 											if ( depth + 1 >= maxDepth ) {
> 
> 												// Only substitute handlers pass on context
> 												// and multiple values (non-spec behavior)
> 												if ( handler !== Thrower ) {
> 													that = undefined;
> 													args = [ e ];
> 												}
> 
> 												deferred.rejectWith( that, args );
> 											}
> 										}
> 									};
> 
> 							// Support: Promises/A+ section 2.3.3.3.1
> 							// https://promisesaplus.com/#point-57
> 							// Re-resolve promises immediately to dodge false rejection from
> 							// subsequent errors
> 							if ( depth ) {
> 								process();
> 							} else {
> 
> 								// Call an optional hook to record the stack, in case of exception
> 								// since it's otherwise lost when execution goes async
> 								if ( jQuery.Deferred.getStackHook ) {
> 									process.stackTrace = jQuery.Deferred.getStackHook();
> 								}
> 								window.setTimeout( process );
> 							}
> 						};
> 					}
> 
> 					return jQuery.Deferred( function( newDefer ) {
> 
> 						// progress_handlers.add( ... )
> 						tuples[ 0 ][ 3 ].add(
> 							resolve(
> 								0,
> 								newDefer,
> 								isFunction( onProgress ) ?
> 									onProgress :
> 									Identity,
> 								newDefer.notifyWith
> 							)
> 						);
> 
> 						// fulfilled_handlers.add( ... )
> 						tuples[ 1 ][ 3 ].add(
> 							resolve(
> 								0,
> 								newDefer,
> 								isFunction( onFulfilled ) ?
> 									onFulfilled :
> 									Identity
> 							)
> 						);
> 
> 						// rejected_handlers.add( ... )
> 						tuples[ 2 ][ 3 ].add(
> 							resolve(
> 								0,
> 								newDefer,
> 								isFunction( onRejected ) ?
> 									onRejected :
> 									Thrower
> 							)
> 						);
> 					} ).promise();
3269a3705
> 
3278,3280d3713
< 		// Keep pipe for back-compat
< 		promise.pipe = promise.then;
< 
3284c3717
< 				stateString = tuple[ 3 ];
---
> 				stateString = tuple[ 5 ];
3286,3287c3719,3722
< 			// promise[ done | fail | progress ] = list.add
< 			promise[ tuple[1] ] = list.add;
---
> 			// promise.progress = list.add
> 			// promise.done = list.add
> 			// promise.fail = list.add
> 			promise[ tuple[ 1 ] ] = list.add;
3291,3293c3726,3727
< 				list.add(function() {
< 					// state = [ resolved | rejected ]
< 					state = stateString;
---
> 				list.add(
> 					function() {
3295,3296c3729,3747
< 				// [ reject_list | resolve_list ].disable; progress_list.lock
< 				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
---
> 						// state = "resolved" (i.e., fulfilled)
> 						// state = "rejected"
> 						state = stateString;
> 					},
> 
> 					// rejected_callbacks.disable
> 					// fulfilled_callbacks.disable
> 					tuples[ 3 - i ][ 2 ].disable,
> 
> 					// rejected_handlers.disable
> 					// fulfilled_handlers.disable
> 					tuples[ 3 - i ][ 3 ].disable,
> 
> 					// progress_callbacks.lock
> 					tuples[ 0 ][ 2 ].lock,
> 
> 					// progress_handlers.lock
> 					tuples[ 0 ][ 3 ].lock
> 				);
3299,3301c3750,3759
< 			// deferred[ resolve | reject | notify ]
< 			deferred[ tuple[0] ] = function() {
< 				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
---
> 			// progress_handlers.fire
> 			// fulfilled_handlers.fire
> 			// rejected_handlers.fire
> 			list.add( tuple[ 3 ].fire );
> 
> 			// deferred.notify = function() { deferred.notifyWith(...) }
> 			// deferred.resolve = function() { deferred.resolveWith(...) }
> 			// deferred.reject = function() { deferred.rejectWith(...) }
> 			deferred[ tuple[ 0 ] ] = function() {
> 				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
3304,3305c3762,3767
< 			deferred[ tuple[0] + "With" ] = list.fireWith;
< 		});
---
> 
> 			// deferred.notifyWith = list.fireWith
> 			// deferred.resolveWith = list.fireWith
> 			// deferred.rejectWith = list.fireWith
> 			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
> 		} );
3320,3323c3782,3789
< 	when: function( subordinate /* , ..., subordinateN */ ) {
< 		var i = 0,
< 			resolveValues = slice.call( arguments ),
< 			length = resolveValues.length,
---
> 	when: function( singleValue ) {
> 		var
> 
> 			// count of uncompleted subordinates
> 			remaining = arguments.length,
> 
> 			// count of unprocessed arguments
> 			i = remaining,
3325,3326c3791,3793
< 			// the count of uncompleted subordinates
< 			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,
---
> 			// subordinate fulfillment data
> 			resolveContexts = Array( i ),
> 			resolveValues = slice.call( arguments ),
3328,3329c3795,3796
< 			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
< 			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
---
> 			// the master Deferred
> 			master = jQuery.Deferred(),
3331,3332c3798,3799
< 			// Update function for both resolve and progress values
< 			updateFunc = function( i, contexts, values ) {
---
> 			// subordinate callback factory
> 			updateFunc = function( i ) {
3334,3339c3801,3804
< 					contexts[ i ] = this;
< 					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
< 					if ( values === progressValues ) {
< 						deferred.notifyWith( contexts, values );
< 					} else if ( !( --remaining ) ) {
< 						deferred.resolveWith( contexts, values );
---
> 					resolveContexts[ i ] = this;
> 					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
> 					if ( !( --remaining ) ) {
> 						master.resolveWith( resolveContexts, resolveValues );
3342c3807
< 			},
---
> 			};
3344c3809,3812
< 			progressValues, progressContexts, resolveContexts;
---
> 		// Single- and empty arguments are adopted like Promise.resolve
> 		if ( remaining <= 1 ) {
> 			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
> 				!remaining );
3346,3359c3814,3818
< 		// Add listeners to Deferred subordinates; treat others as resolved
< 		if ( length > 1 ) {
< 			progressValues = new Array( length );
< 			progressContexts = new Array( length );
< 			resolveContexts = new Array( length );
< 			for ( ; i < length; i++ ) {
< 				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
< 					resolveValues[ i ].promise()
< 						.done( updateFunc( i, resolveContexts, resolveValues ) )
< 						.fail( deferred.reject )
< 						.progress( updateFunc( i, progressContexts, progressValues ) );
< 				} else {
< 					--remaining;
< 				}
---
> 			// Use .then() to unwrap secondary thenables (cf. gh-3000)
> 			if ( master.state() === "pending" ||
> 				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
> 
> 				return master.then();
3363,3365c3822,3824
< 		// If we're not waiting on anything, resolve the master
< 		if ( !remaining ) {
< 			deferred.resolveWith( resolveContexts, resolveValues );
---
> 		// Multiple arguments are aggregated like Promise.all array elements
> 		while ( i-- ) {
> 			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
3368c3827
< 		return deferred.promise();
---
> 		return master.promise();
3370c3829,3854
< });
---
> } );
> 
> 
> // These usually indicate a programmer mistake during development,
> // warn about them ASAP rather than swallowing them by default.
> var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
> 
> jQuery.Deferred.exceptionHook = function( error, stack ) {
> 
> 	// Support: IE 8 - 9 only
> 	// Console exists when dev tools are open, which can happen at any time
> 	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
> 		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
> 	}
> };
> 
> 
> 
> 
> jQuery.readyException = function( error ) {
> 	window.setTimeout( function() {
> 		throw error;
> 	} );
> };
> 
> 
3374c3858
< var readyList;
---
> var readyList = jQuery.Deferred();
3377,3378c3861,3870
< 	// Add the callback
< 	jQuery.ready.promise().done( fn );
---
> 
> 	readyList
> 		.then( fn )
> 
> 		// Wrap jQuery.readyException in a function so that the lookup
> 		// happens at the time of error handling instead of callback
> 		// registration.
> 		.catch( function( error ) {
> 			jQuery.readyException( error );
> 		} );
3383c3875,3876
< jQuery.extend({
---
> jQuery.extend( {
> 
3391,3399d3883
< 	// Hold (or release) the ready event
< 	holdReady: function( hold ) {
< 		if ( hold ) {
< 			jQuery.readyWait++;
< 		} else {
< 			jQuery.ready( true );
< 		}
< 	},
< 
3418,3423d3901
< 
< 		// Trigger any bound ready events
< 		if ( jQuery.fn.triggerHandler ) {
< 			jQuery( document ).triggerHandler( "ready" );
< 			jQuery( document ).off( "ready" );
< 		}
3425c3903
< });
---
> } );
3427,3429c3905,3907
< /**
<  * The ready event handler and self cleanup method
<  */
---
> jQuery.ready.then = readyList.then;
> 
> // The ready event handler and self cleanup method
3431,3432c3909,3910
< 	document.removeEventListener( "DOMContentLoaded", completed, false );
< 	window.removeEventListener( "load", completed, false );
---
> 	document.removeEventListener( "DOMContentLoaded", completed );
> 	window.removeEventListener( "load", completed );
3436,3437c3914,3922
< jQuery.ready.promise = function( obj ) {
< 	if ( !readyList ) {
---
> // Catch cases where $(document).ready() is called
> // after the browser event has already occurred.
> // Support: IE <=9 - 10 only
> // Older IE sometimes signals "interactive" too soon
> if ( document.readyState === "complete" ||
> 	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
> 
> 	// Handle it asynchronously to allow scripts the opportunity to delay ready
> 	window.setTimeout( jQuery.ready );
3439c3924
< 		readyList = jQuery.Deferred();
---
> } else {
3441,3446c3926,3927
< 		// Catch cases where $(document).ready() is called after the browser event has already occurred.
< 		// We once tried to use readyState "interactive" here, but it caused issues like the one
< 		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
< 		if ( document.readyState === "complete" ) {
< 			// Handle it asynchronously to allow scripts the opportunity to delay ready
< 			setTimeout( jQuery.ready );
---
> 	// Use the handy event callback
> 	document.addEventListener( "DOMContentLoaded", completed );
3448,3461c3929,3931
< 		} else {
< 
< 			// Use the handy event callback
< 			document.addEventListener( "DOMContentLoaded", completed, false );
< 
< 			// A fallback to window.onload, that will always work
< 			window.addEventListener( "load", completed, false );
< 		}
< 	}
< 	return readyList.promise( obj );
< };
< 
< // Kick off the DOM ready check even if the user does not
< jQuery.ready.promise();
---
> 	// A fallback to window.onload, that will always work
> 	window.addEventListener( "load", completed );
> }
3468c3938
< var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
---
> var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
3474c3944
< 	if ( jQuery.type( key ) === "object" ) {
---
> 	if ( toType( key ) === "object" ) {
3477c3947
< 			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
---
> 			access( elems, fn, i, key[ i ], true, emptyGet, raw );
3484c3954
< 		if ( !jQuery.isFunction( value ) ) {
---
> 		if ( !isFunction( value ) ) {
3488a3959
> 
3505c3976,3980
< 				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
---
> 				fn(
> 					elems[ i ], key, raw ?
> 					value :
> 					value.call( elems[ i ], i, fn( elems[ i ], key ) )
> 				);
3510,3511c3985,3992
< 	return chainable ?
< 		elems :
---
> 	if ( chainable ) {
> 		return elems;
> 	}
> 
> 	// Gets
> 	if ( bulk ) {
> 		return fn.call( elems );
> 	}
3513,3516c3994
< 		// Gets
< 		bulk ?
< 			fn.call( elems ) :
< 			len ? fn( elems[0], key ) : emptyGet;
---
> 	return len ? fn( elems[ 0 ], key ) : emptyGet;
3520,3523c3998,4014
< /**
<  * Determines whether an object can have data
<  */
< jQuery.acceptData = function( owner ) {
---
> // Matches dashed string for camelizing
> var rmsPrefix = /^-ms-/,
> 	rdashAlpha = /-([a-z])/g;
> 
> // Used by camelCase as callback to replace()
> function fcamelCase( all, letter ) {
> 	return letter.toUpperCase();
> }
> 
> // Convert dashed to camelCase; used by the css and data modules
> // Support: IE <=9 - 11, Edge 12 - 15
> // Microsoft forgot to hump their vendor prefix (#9572)
> function camelCase( string ) {
> 	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
> }
> var acceptData = function( owner ) {
> 
3530d4020
< 	/* jshint -W018 */
3535,3543d4024
< function Data() {
< 	// Support: Android<4,
< 	// Old WebKit does not have Object.preventExtensions/freeze method,
< 	// return new empty object instead with no [[set]] accessor
< 	Object.defineProperty( this.cache = {}, 0, {
< 		get: function() {
< 			return {};
< 		}
< 	});
3544a4026,4027
> 
> function Data() {
3549d4031
< Data.accepts = jQuery.acceptData;
3552,3558d4033
< 	key: function( owner ) {
< 		// We can accept data for non-element nodes in modern browsers,
< 		// but we should not, see #8335.
< 		// Always return the key for a frozen object.
< 		if ( !Data.accepts( owner ) ) {
< 			return 0;
< 		}
3560,3562c4035
< 		var descriptor = {},
< 			// Check if the owner object already has a cache key
< 			unlock = owner[ this.expando ];
---
> 	cache: function( owner ) {
3564,3566c4037,4038
< 		// If not, create one
< 		if ( !unlock ) {
< 			unlock = Data.uid++;
---
> 		// Check if the owner object already has a cache
> 		var value = owner[ this.expando ];
3568,3571c4040,4042
< 			// Secure it in a non-enumerable, non-writable property
< 			try {
< 				descriptor[ this.expando ] = { value: unlock };
< 				Object.defineProperties( owner, descriptor );
---
> 		// If not, create one
> 		if ( !value ) {
> 			value = {};
3573,3577c4044,4062
< 			// Support: Android<4
< 			// Fallback to a less secure definition
< 			} catch ( e ) {
< 				descriptor[ this.expando ] = unlock;
< 				jQuery.extend( owner, descriptor );
---
> 			// We can accept data for non-element nodes in modern browsers,
> 			// but we should not, see #8335.
> 			// Always return an empty object.
> 			if ( acceptData( owner ) ) {
> 
> 				// If it is a node unlikely to be stringify-ed or looped over
> 				// use plain assignment
> 				if ( owner.nodeType ) {
> 					owner[ this.expando ] = value;
> 
> 				// Otherwise secure it in a non-enumerable property
> 				// configurable must be true to allow the property to be
> 				// deleted when data is removed
> 				} else {
> 					Object.defineProperty( owner, this.expando, {
> 						value: value,
> 						configurable: true
> 					} );
> 				}
3581,3586c4066
< 		// Ensure the cache object
< 		if ( !this.cache[ unlock ] ) {
< 			this.cache[ unlock ] = {};
< 		}
< 
< 		return unlock;
---
> 		return value;
3590,3594c4070
< 			// There may be an unlock assigned to this node,
< 			// if there is no entry for this "owner", create one inline
< 			// and set the unlock as though an owner entry had always existed
< 			unlock = this.key( owner ),
< 			cache = this.cache[ unlock ];
---
> 			cache = this.cache( owner );
3596a4073
> 		// Always use camelCase key (gh-2257)
3598c4075
< 			cache[ data ] = value;
---
> 			cache[ camelCase( data ) ] = value;
3602,3609c4079,4082
< 			// Fresh assignments by object are shallow copied
< 			if ( jQuery.isEmptyObject( cache ) ) {
< 				jQuery.extend( this.cache[ unlock ], data );
< 			// Otherwise, copy the properties one-by-one to the cache object
< 			} else {
< 				for ( prop in data ) {
< 					cache[ prop ] = data[ prop ];
< 				}
---
> 
> 			// Copy the properties one-by-one to the cache object
> 			for ( prop in data ) {
> 				cache[ camelCase( prop ) ] = data[ prop ];
3615,3620d4087
< 		// Either a valid cache is found, or will be created.
< 		// New caches will be created and the unlock returned,
< 		// allowing direct access to the newly created
< 		// empty data object. A valid owner object must be provided.
< 		var cache = this.cache[ this.key( owner ) ];
< 
3622c4089,4092
< 			cache : cache[ key ];
---
> 			this.cache( owner ) :
> 
> 			// Always use camelCase key (gh-2257)
> 			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
3625c4095
< 		var stored;
---
> 
3638c4108
< 				((key && typeof key === "string") && value === undefined) ) {
---
> 				( ( key && typeof key === "string" ) && value === undefined ) ) {
3640,3643c4110
< 			stored = this.get( owner, key );
< 
< 			return stored !== undefined ?
< 				stored : this.get( owner, jQuery.camelCase(key) );
---
> 			return this.get( owner, key );
3646c4113
< 		// [*]When the key is not a string, or both a key and value
---
> 		// When the key is not a string, or both a key and value
3659,3661c4126,4127
< 		var i, name, camel,
< 			unlock = this.key( owner ),
< 			cache = this.cache[ unlock ];
---
> 		var i,
> 			cache = owner[ this.expando ];
3663,3664c4129,4133
< 		if ( key === undefined ) {
< 			this.cache[ unlock ] = {};
---
> 		if ( cache === undefined ) {
> 			return;
> 		}
> 
> 		if ( key !== undefined ) {
3666d4134
< 		} else {
3668,3675c4136,4140
< 			if ( jQuery.isArray( key ) ) {
< 				// If "name" is an array of keys...
< 				// When data is initially created, via ("key", "val") signature,
< 				// keys will be converted to camelCase.
< 				// Since there is no way to tell _how_ a key was added, remove
< 				// both plain key and camelCase key. #12786
< 				// This will only penalize the array argument path.
< 				name = key.concat( key.map( jQuery.camelCase ) );
---
> 			if ( Array.isArray( key ) ) {
> 
> 				// If key is an array of keys...
> 				// We always set camelCase keys, so remove that.
> 				key = key.map( camelCase );
3677,3687c4142,4148
< 				camel = jQuery.camelCase( key );
< 				// Try the string as a key before any manipulation
< 				if ( key in cache ) {
< 					name = [ key, camel ];
< 				} else {
< 					// If a key with the spaces exists, use it.
< 					// Otherwise, create an array by matching non-whitespace
< 					name = camel;
< 					name = name in cache ?
< 						[ name ] : ( name.match( rnotwhite ) || [] );
< 				}
---
> 				key = camelCase( key );
> 
> 				// If a key with the spaces exists, use it.
> 				// Otherwise, create an array by matching non-whitespace
> 				key = key in cache ?
> 					[ key ] :
> 					( key.match( rnothtmlwhite ) || [] );
3690c4151,4152
< 			i = name.length;
---
> 			i = key.length;
> 
3692c4154,4168
< 				delete cache[ name[ i ] ];
---
> 				delete cache[ key[ i ] ];
> 			}
> 		}
> 
> 		// Remove the expando if there's no more data
> 		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
> 
> 			// Support: Chrome <=35 - 45
> 			// Webkit & Blink performance suffers when deleting properties
> 			// from DOM nodes, so set to undefined instead
> 			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
> 			if ( owner.nodeType ) {
> 				owner[ this.expando ] = undefined;
> 			} else {
> 				delete owner[ this.expando ];
3697,3704c4173,4174
< 		return !jQuery.isEmptyObject(
< 			this.cache[ owner[ this.expando ] ] || {}
< 		);
< 	},
< 	discard: function( owner ) {
< 		if ( owner[ this.expando ] ) {
< 			delete this.cache[ owner[ this.expando ] ];
< 		}
---
> 		var cache = owner[ this.expando ];
> 		return cache !== undefined && !jQuery.isEmptyObject( cache );
3707c4177
< var data_priv = new Data();
---
> var dataPriv = new Data();
3709c4179
< var data_user = new Data();
---
> var dataUser = new Data();
3724c4194,4219
< 	rmultiDash = /([A-Z])/g;
---
> 	rmultiDash = /[A-Z]/g;
> 
> function getData( data ) {
> 	if ( data === "true" ) {
> 		return true;
> 	}
> 
> 	if ( data === "false" ) {
> 		return false;
> 	}
> 
> 	if ( data === "null" ) {
> 		return null;
> 	}
> 
> 	// Only convert to a number if it doesn't change the string
> 	if ( data === +data + "" ) {
> 		return +data;
> 	}
> 
> 	if ( rbrace.test( data ) ) {
> 		return JSON.parse( data );
> 	}
> 
> 	return data;
> }
3732c4227
< 		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
---
> 		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
3737,3744c4232,4233
< 				data = data === "true" ? true :
< 					data === "false" ? false :
< 					data === "null" ? null :
< 					// Only convert to a number if it doesn't change the string
< 					+data + "" === data ? +data :
< 					rbrace.test( data ) ? jQuery.parseJSON( data ) :
< 					data;
< 			} catch( e ) {}
---
> 				data = getData( data );
> 			} catch ( e ) {}
3747c4236
< 			data_user.set( elem, key, data );
---
> 			dataUser.set( elem, key, data );
3755c4244
< jQuery.extend({
---
> jQuery.extend( {
3757c4246
< 		return data_user.hasData( elem ) || data_priv.hasData( elem );
---
> 		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
3761c4250
< 		return data_user.access( elem, name, data );
---
> 		return dataUser.access( elem, name, data );
3765c4254
< 		data_user.remove( elem, name );
---
> 		dataUser.remove( elem, name );
3769c4258
< 	// with direct calls to data_priv methods, these can be deprecated.
---
> 	// with direct calls to dataPriv methods, these can be deprecated.
3771c4260
< 		return data_priv.access( elem, name, data );
---
> 		return dataPriv.access( elem, name, data );
3775c4264
< 		data_priv.remove( elem, name );
---
> 		dataPriv.remove( elem, name );
3777c4266
< });
---
> } );
3779c4268
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
3788c4277
< 				data = data_user.get( elem );
---
> 				data = dataUser.get( elem );
3790c4279
< 				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
---
> 				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
3794c4283
< 						// Support: IE11+
---
> 						// Support: IE 11 only
3799c4288
< 								name = jQuery.camelCase( name.slice(5) );
---
> 								name = camelCase( name.slice( 5 ) );
3804c4293
< 					data_priv.set( elem, "hasDataAttrs", true );
---
> 					dataPriv.set( elem, "hasDataAttrs", true );
3813,3815c4302,4304
< 			return this.each(function() {
< 				data_user.set( this, key );
< 			});
---
> 			return this.each( function() {
> 				dataUser.set( this, key );
> 			} );
3819,3820c4308
< 			var data,
< 				camelKey = jQuery.camelCase( key );
---
> 			var data;
3828,3833d4315
< 				// Attempt to get data from the cache
< 				// with the key as-is
< 				data = data_user.get( elem, key );
< 				if ( data !== undefined ) {
< 					return data;
< 				}
3836,3837c4318,4319
< 				// with the key camelized
< 				data = data_user.get( elem, camelKey );
---
> 				// The key will always be camelCased in Data
> 				data = dataUser.get( elem, key );
3844c4326
< 				data = dataAttr( elem, camelKey, undefined );
---
> 				data = dataAttr( elem, key );
3854,3870c4336,4340
< 			this.each(function() {
< 				// First, attempt to store a copy or reference of any
< 				// data that might've been store with a camelCased key.
< 				var data = data_user.get( this, camelKey );
< 
< 				// For HTML5 data-* attribute interop, we have to
< 				// store property names with dashes in a camelCase form.
< 				// This might not apply to all properties...*
< 				data_user.set( this, camelKey, value );
< 
< 				// *... In the case of properties that might _actually_
< 				// have dashes, we need to also store a copy of that
< 				// unchanged property.
< 				if ( key.indexOf("-") !== -1 && data !== undefined ) {
< 					data_user.set( this, key, value );
< 				}
< 			});
---
> 			this.each( function() {
> 
> 				// We always store the camelCased key
> 				dataUser.set( this, key, value );
> 			} );
3875,3877c4345,4347
< 		return this.each(function() {
< 			data_user.remove( this, key );
< 		});
---
> 		return this.each( function() {
> 			dataUser.remove( this, key );
> 		} );
3879c4349
< });
---
> } );
3882c4352
< jQuery.extend({
---
> jQuery.extend( {
3888c4358
< 			queue = data_priv.get( elem, type );
---
> 			queue = dataPriv.get( elem, type );
3892,3893c4362,4363
< 				if ( !queue || jQuery.isArray( data ) ) {
< 					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
---
> 				if ( !queue || Array.isArray( data ) ) {
> 					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
3940,3944c4410,4414
< 		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
< 			empty: jQuery.Callbacks("once memory").add(function() {
< 				data_priv.remove( elem, [ type + "queue", key ] );
< 			})
< 		});
---
> 		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
> 			empty: jQuery.Callbacks( "once memory" ).add( function() {
> 				dataPriv.remove( elem, [ type + "queue", key ] );
> 			} )
> 		} );
3946c4416
< });
---
> } );
3948c4418
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
3959c4429
< 			return jQuery.queue( this[0], type );
---
> 			return jQuery.queue( this[ 0 ], type );
3964c4434
< 			this.each(function() {
---
> 			this.each( function() {
3970c4440
< 				if ( type === "fx" && queue[0] !== "inprogress" ) {
---
> 				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
3973c4443
< 			});
---
> 			} );
3976c4446
< 		return this.each(function() {
---
> 		return this.each( function() {
3978c4448
< 		});
---
> 		} );
3982a4453
> 
4004c4475
< 			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
---
> 			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
4013,4014c4484,4488
< });
< var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
---
> } );
> var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
> 
> var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
> 
4018,4019c4492,4514
< var isHidden = function( elem, el ) {
< 		// isHidden might be called from jQuery#filter function;
---
> var documentElement = document.documentElement;
> 
> 
> 
> 	var isAttached = function( elem ) {
> 			return jQuery.contains( elem.ownerDocument, elem );
> 		},
> 		composed = { composed: true };
> 
> 	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
> 	// Check attachment across shadow DOM boundaries when possible (gh-3504)
> 	// Support: iOS 10.0-10.2 only
> 	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
> 	// leading to errors. We need to check for `getRootNode`.
> 	if ( documentElement.getRootNode ) {
> 		isAttached = function( elem ) {
> 			return jQuery.contains( elem.ownerDocument, elem ) ||
> 				elem.getRootNode( composed ) === elem.ownerDocument;
> 		};
> 	}
> var isHiddenWithinTree = function( elem, el ) {
> 
> 		// isHiddenWithinTree might be called from jQuery#filter function;
4022c4517,4528
< 		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
---
> 
> 		// Inline style trumps all
> 		return elem.style.display === "none" ||
> 			elem.style.display === "" &&
> 
> 			// Otherwise, check computed style
> 			// Support: Firefox <=43 - 45
> 			// Disconnected elements can have computed display: none, so first confirm that elem is
> 			// in the document.
> 			isAttached( elem ) &&
> 
> 			jQuery.css( elem, "display" ) === "none";
4025c4531,4549
< var rcheckableType = (/^(?:checkbox|radio)$/i);
---
> var swap = function( elem, options, callback, args ) {
> 	var ret, name,
> 		old = {};
> 
> 	// Remember the old values, and insert the new ones
> 	for ( name in options ) {
> 		old[ name ] = elem.style[ name ];
> 		elem.style[ name ] = options[ name ];
> 	}
> 
> 	ret = callback.apply( elem, args || [] );
> 
> 	// Revert the old values
> 	for ( name in options ) {
> 		elem.style[ name ] = old[ name ];
> 	}
> 
> 	return ret;
> };
4029c4553,4877
< (function() {
---
> 
> function adjustCSS( elem, prop, valueParts, tween ) {
> 	var adjusted, scale,
> 		maxIterations = 20,
> 		currentValue = tween ?
> 			function() {
> 				return tween.cur();
> 			} :
> 			function() {
> 				return jQuery.css( elem, prop, "" );
> 			},
> 		initial = currentValue(),
> 		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
> 
> 		// Starting value computation is required for potential unit mismatches
> 		initialInUnit = elem.nodeType &&
> 			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
> 			rcssNum.exec( jQuery.css( elem, prop ) );
> 
> 	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
> 
> 		// Support: Firefox <=54
> 		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
> 		initial = initial / 2;
> 
> 		// Trust units reported by jQuery.css
> 		unit = unit || initialInUnit[ 3 ];
> 
> 		// Iteratively approximate from a nonzero starting point
> 		initialInUnit = +initial || 1;
> 
> 		while ( maxIterations-- ) {
> 
> 			// Evaluate and update our best guess (doubling guesses that zero out).
> 			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
> 			jQuery.style( elem, prop, initialInUnit + unit );
> 			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
> 				maxIterations = 0;
> 			}
> 			initialInUnit = initialInUnit / scale;
> 
> 		}
> 
> 		initialInUnit = initialInUnit * 2;
> 		jQuery.style( elem, prop, initialInUnit + unit );
> 
> 		// Make sure we update the tween properties later on
> 		valueParts = valueParts || [];
> 	}
> 
> 	if ( valueParts ) {
> 		initialInUnit = +initialInUnit || +initial || 0;
> 
> 		// Apply relative offset (+=/-=) if specified
> 		adjusted = valueParts[ 1 ] ?
> 			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
> 			+valueParts[ 2 ];
> 		if ( tween ) {
> 			tween.unit = unit;
> 			tween.start = initialInUnit;
> 			tween.end = adjusted;
> 		}
> 	}
> 	return adjusted;
> }
> 
> 
> var defaultDisplayMap = {};
> 
> function getDefaultDisplay( elem ) {
> 	var temp,
> 		doc = elem.ownerDocument,
> 		nodeName = elem.nodeName,
> 		display = defaultDisplayMap[ nodeName ];
> 
> 	if ( display ) {
> 		return display;
> 	}
> 
> 	temp = doc.body.appendChild( doc.createElement( nodeName ) );
> 	display = jQuery.css( temp, "display" );
> 
> 	temp.parentNode.removeChild( temp );
> 
> 	if ( display === "none" ) {
> 		display = "block";
> 	}
> 	defaultDisplayMap[ nodeName ] = display;
> 
> 	return display;
> }
> 
> function showHide( elements, show ) {
> 	var display, elem,
> 		values = [],
> 		index = 0,
> 		length = elements.length;
> 
> 	// Determine new display value for elements that need to change
> 	for ( ; index < length; index++ ) {
> 		elem = elements[ index ];
> 		if ( !elem.style ) {
> 			continue;
> 		}
> 
> 		display = elem.style.display;
> 		if ( show ) {
> 
> 			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
> 			// check is required in this first loop unless we have a nonempty display value (either
> 			// inline or about-to-be-restored)
> 			if ( display === "none" ) {
> 				values[ index ] = dataPriv.get( elem, "display" ) || null;
> 				if ( !values[ index ] ) {
> 					elem.style.display = "";
> 				}
> 			}
> 			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
> 				values[ index ] = getDefaultDisplay( elem );
> 			}
> 		} else {
> 			if ( display !== "none" ) {
> 				values[ index ] = "none";
> 
> 				// Remember what we're overwriting
> 				dataPriv.set( elem, "display", display );
> 			}
> 		}
> 	}
> 
> 	// Set the display of the elements in a second loop to avoid constant reflow
> 	for ( index = 0; index < length; index++ ) {
> 		if ( values[ index ] != null ) {
> 			elements[ index ].style.display = values[ index ];
> 		}
> 	}
> 
> 	return elements;
> }
> 
> jQuery.fn.extend( {
> 	show: function() {
> 		return showHide( this, true );
> 	},
> 	hide: function() {
> 		return showHide( this );
> 	},
> 	toggle: function( state ) {
> 		if ( typeof state === "boolean" ) {
> 			return state ? this.show() : this.hide();
> 		}
> 
> 		return this.each( function() {
> 			if ( isHiddenWithinTree( this ) ) {
> 				jQuery( this ).show();
> 			} else {
> 				jQuery( this ).hide();
> 			}
> 		} );
> 	}
> } );
> var rcheckableType = ( /^(?:checkbox|radio)$/i );
> 
> var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );
> 
> var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );
> 
> 
> 
> // We have to close these tags to support XHTML (#13200)
> var wrapMap = {
> 
> 	// Support: IE <=9 only
> 	option: [ 1, "<select multiple='multiple'>", "</select>" ],
> 
> 	// XHTML parsers do not magically insert elements in the
> 	// same way that tag soup parsers do. So we cannot shorten
> 	// this by omitting <tbody> or other required elements.
> 	thead: [ 1, "<table>", "</table>" ],
> 	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
> 	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
> 	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
> 
> 	_default: [ 0, "", "" ]
> };
> 
> // Support: IE <=9 only
> wrapMap.optgroup = wrapMap.option;
> 
> wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
> wrapMap.th = wrapMap.td;
> 
> 
> function getAll( context, tag ) {
> 
> 	// Support: IE <=9 - 11 only
> 	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
> 	var ret;
> 
> 	if ( typeof context.getElementsByTagName !== "undefined" ) {
> 		ret = context.getElementsByTagName( tag || "*" );
> 
> 	} else if ( typeof context.querySelectorAll !== "undefined" ) {
> 		ret = context.querySelectorAll( tag || "*" );
> 
> 	} else {
> 		ret = [];
> 	}
> 
> 	if ( tag === undefined || tag && nodeName( context, tag ) ) {
> 		return jQuery.merge( [ context ], ret );
> 	}
> 
> 	return ret;
> }
> 
> 
> // Mark scripts as having already been evaluated
> function setGlobalEval( elems, refElements ) {
> 	var i = 0,
> 		l = elems.length;
> 
> 	for ( ; i < l; i++ ) {
> 		dataPriv.set(
> 			elems[ i ],
> 			"globalEval",
> 			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
> 		);
> 	}
> }
> 
> 
> var rhtml = /<|&#?\w+;/;
> 
> function buildFragment( elems, context, scripts, selection, ignored ) {
> 	var elem, tmp, tag, wrap, attached, j,
> 		fragment = context.createDocumentFragment(),
> 		nodes = [],
> 		i = 0,
> 		l = elems.length;
> 
> 	for ( ; i < l; i++ ) {
> 		elem = elems[ i ];
> 
> 		if ( elem || elem === 0 ) {
> 
> 			// Add nodes directly
> 			if ( toType( elem ) === "object" ) {
> 
> 				// Support: Android <=4.0 only, PhantomJS 1 only
> 				// push.apply(_, arraylike) throws on ancient WebKit
> 				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
> 
> 			// Convert non-html into a text node
> 			} else if ( !rhtml.test( elem ) ) {
> 				nodes.push( context.createTextNode( elem ) );
> 
> 			// Convert html into DOM nodes
> 			} else {
> 				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
> 
> 				// Deserialize a standard representation
> 				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
> 				wrap = wrapMap[ tag ] || wrapMap._default;
> 				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
> 
> 				// Descend through wrappers to the right content
> 				j = wrap[ 0 ];
> 				while ( j-- ) {
> 					tmp = tmp.lastChild;
> 				}
> 
> 				// Support: Android <=4.0 only, PhantomJS 1 only
> 				// push.apply(_, arraylike) throws on ancient WebKit
> 				jQuery.merge( nodes, tmp.childNodes );
> 
> 				// Remember the top-level container
> 				tmp = fragment.firstChild;
> 
> 				// Ensure the created nodes are orphaned (#12392)
> 				tmp.textContent = "";
> 			}
> 		}
> 	}
> 
> 	// Remove wrapper from fragment
> 	fragment.textContent = "";
> 
> 	i = 0;
> 	while ( ( elem = nodes[ i++ ] ) ) {
> 
> 		// Skip elements already in the context collection (trac-4087)
> 		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
> 			if ( ignored ) {
> 				ignored.push( elem );
> 			}
> 			continue;
> 		}
> 
> 		attached = isAttached( elem );
> 
> 		// Append to fragment
> 		tmp = getAll( fragment.appendChild( elem ), "script" );
> 
> 		// Preserve script evaluation history
> 		if ( attached ) {
> 			setGlobalEval( tmp );
> 		}
> 
> 		// Capture executables
> 		if ( scripts ) {
> 			j = 0;
> 			while ( ( elem = tmp[ j++ ] ) ) {
> 				if ( rscriptType.test( elem.type || "" ) ) {
> 					scripts.push( elem );
> 				}
> 			}
> 		}
> 	}
> 
> 	return fragment;
> }
> 
> 
> ( function() {
4034c4882
< 	// Support: Safari<=5.1
---
> 	// Support: Android 4.0 - 4.3 only
4044c4892
< 	// Support: Safari<=5.1, Android<4.2
---
> 	// Support: Android <=4.1 only
4048c4896
< 	// Support: IE<=11+
---
> 	// Support: IE <=11 only
4052,4057c4900
< })();
< var strundefined = typeof undefined;
< 
< 
< 
< support.focusinBubbles = "onfocusin" in window;
---
> } )();
4062,4064c4905,4906
< 	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
< 	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
< 	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
---
> 	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
> 	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
4073a4916,4928
> // Support: IE <=9 - 11+
> // focus() and blur() are asynchronous, except when they are no-op.
> // So expect focus to be synchronous when the element is already active,
> // and blur to be synchronous when the element is not already active.
> // (focus and blur are always synchronous in other supported browsers,
> // this just defines when we can count on it).
> function expectSync( elem, type ) {
> 	return ( elem === safeActiveElement() ) === ( type === "focus" );
> }
> 
> // Support: IE <=9 only
> // Accessing document.activeElement can throw unexpectedly
> // https://bugs.jquery.com/ticket/13393
4079a4935,4995
> function on( elem, types, selector, data, fn, one ) {
> 	var origFn, type;
> 
> 	// Types can be a map of types/handlers
> 	if ( typeof types === "object" ) {
> 
> 		// ( types-Object, selector, data )
> 		if ( typeof selector !== "string" ) {
> 
> 			// ( types-Object, data )
> 			data = data || selector;
> 			selector = undefined;
> 		}
> 		for ( type in types ) {
> 			on( elem, type, selector, data, types[ type ], one );
> 		}
> 		return elem;
> 	}
> 
> 	if ( data == null && fn == null ) {
> 
> 		// ( types, fn )
> 		fn = selector;
> 		data = selector = undefined;
> 	} else if ( fn == null ) {
> 		if ( typeof selector === "string" ) {
> 
> 			// ( types, selector, fn )
> 			fn = data;
> 			data = undefined;
> 		} else {
> 
> 			// ( types, data, fn )
> 			fn = data;
> 			data = selector;
> 			selector = undefined;
> 		}
> 	}
> 	if ( fn === false ) {
> 		fn = returnFalse;
> 	} else if ( !fn ) {
> 		return elem;
> 	}
> 
> 	if ( one === 1 ) {
> 		origFn = fn;
> 		fn = function( event ) {
> 
> 			// Can use an empty set, since event contains the info
> 			jQuery().off( event );
> 			return origFn.apply( this, arguments );
> 		};
> 
> 		// Use same guid so caller can remove using origFn
> 		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
> 	}
> 	return elem.each( function() {
> 		jQuery.event.add( this, types, fn, data, selector );
> 	} );
> }
> 
4093c5009
< 			elemData = data_priv.get( elem );
---
> 			elemData = dataPriv.get( elem );
4106a5023,5028
> 		// Ensure that invalid selectors throw exceptions at attach time
> 		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
> 		if ( selector ) {
> 			jQuery.find.matchesSelector( documentElement, selector );
> 		}
> 
4113c5035
< 		if ( !(events = elemData.events) ) {
---
> 		if ( !( events = elemData.events ) ) {
4116c5038
< 		if ( !(eventHandle = elemData.handle) ) {
---
> 		if ( !( eventHandle = elemData.handle ) ) {
4117a5040
> 
4120c5043
< 				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
---
> 				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
4126c5049
< 		types = ( types || "" ).match( rnotwhite ) || [ "" ];
---
> 		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
4129,4131c5052,5054
< 			tmp = rtypenamespace.exec( types[t] ) || [];
< 			type = origType = tmp[1];
< 			namespaces = ( tmp[2] || "" ).split( "." ).sort();
---
> 			tmp = rtypenamespace.exec( types[ t ] ) || [];
> 			type = origType = tmp[ 1 ];
> 			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
4148c5071
< 			handleObj = jQuery.extend({
---
> 			handleObj = jQuery.extend( {
4156c5079
< 				namespace: namespaces.join(".")
---
> 				namespace: namespaces.join( "." )
4160c5083
< 			if ( !(handlers = events[ type ]) ) {
---
> 			if ( !( handlers = events[ type ] ) ) {
4165c5088,5090
< 				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
---
> 				if ( !special.setup ||
> 					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
> 
4167c5092
< 						elem.addEventListener( type, eventHandle, false );
---
> 						elem.addEventListener( type, eventHandle );
4199c5124
< 			elemData = data_priv.hasData( elem ) && data_priv.get( elem );
---
> 			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
4201c5126
< 		if ( !elemData || !(events = elemData.events) ) {
---
> 		if ( !elemData || !( events = elemData.events ) ) {
4206c5131
< 		types = ( types || "" ).match( rnotwhite ) || [ "" ];
---
> 		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
4209,4211c5134,5136
< 			tmp = rtypenamespace.exec( types[t] ) || [];
< 			type = origType = tmp[1];
< 			namespaces = ( tmp[2] || "" ).split( "." ).sort();
---
> 			tmp = rtypenamespace.exec( types[ t ] ) || [];
> 			type = origType = tmp[ 1 ];
> 			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
4224c5149,5150
< 			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );
---
> 			tmp = tmp[ 2 ] &&
> 				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
4234c5160,5161
< 					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
---
> 					( !selector || selector === handleObj.selector ||
> 						selector === "**" && handleObj.selector ) ) {
4249c5176,5178
< 				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
---
> 				if ( !special.teardown ||
> 					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
> 
4257c5186
< 		// Remove the expando if it's no longer used
---
> 		// Remove data and the expando if it's no longer used
4259,4260c5188
< 			delete elemData.handle;
< 			data_priv.remove( elem, "events" );
---
> 			dataPriv.remove( elem, "handle events" );
4264,4396c5192
< 	trigger: function( event, data, elem, onlyHandlers ) {
< 
< 		var i, cur, tmp, bubbleType, ontype, handle, special,
< 			eventPath = [ elem || document ],
< 			type = hasOwn.call( event, "type" ) ? event.type : event,
< 			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];
< 
< 		cur = tmp = elem = elem || document;
< 
< 		// Don't do events on text and comment nodes
< 		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
< 			return;
< 		}
< 
< 		// focus/blur morphs to focusin/out; ensure we're not firing them right now
< 		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
< 			return;
< 		}
< 
< 		if ( type.indexOf(".") >= 0 ) {
< 			// Namespaced trigger; create a regexp to match event type in handle()
< 			namespaces = type.split(".");
< 			type = namespaces.shift();
< 			namespaces.sort();
< 		}
< 		ontype = type.indexOf(":") < 0 && "on" + type;
< 
< 		// Caller can pass in a jQuery.Event object, Object, or just an event type string
< 		event = event[ jQuery.expando ] ?
< 			event :
< 			new jQuery.Event( type, typeof event === "object" && event );
< 
< 		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
< 		event.isTrigger = onlyHandlers ? 2 : 3;
< 		event.namespace = namespaces.join(".");
< 		event.namespace_re = event.namespace ?
< 			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
< 			null;
< 
< 		// Clean up the event in case it is being reused
< 		event.result = undefined;
< 		if ( !event.target ) {
< 			event.target = elem;
< 		}
< 
< 		// Clone any incoming data and prepend the event, creating the handler arg list
< 		data = data == null ?
< 			[ event ] :
< 			jQuery.makeArray( data, [ event ] );
< 
< 		// Allow special events to draw outside the lines
< 		special = jQuery.event.special[ type ] || {};
< 		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
< 			return;
< 		}
< 
< 		// Determine event propagation path in advance, per W3C events spec (#9951)
< 		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
< 		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
< 
< 			bubbleType = special.delegateType || type;
< 			if ( !rfocusMorph.test( bubbleType + type ) ) {
< 				cur = cur.parentNode;
< 			}
< 			for ( ; cur; cur = cur.parentNode ) {
< 				eventPath.push( cur );
< 				tmp = cur;
< 			}
< 
< 			// Only add window if we got to document (e.g., not plain obj or detached DOM)
< 			if ( tmp === (elem.ownerDocument || document) ) {
< 				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
< 			}
< 		}
< 
< 		// Fire handlers on the event path
< 		i = 0;
< 		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {
< 
< 			event.type = i > 1 ?
< 				bubbleType :
< 				special.bindType || type;
< 
< 			// jQuery handler
< 			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
< 			if ( handle ) {
< 				handle.apply( cur, data );
< 			}
< 
< 			// Native handler
< 			handle = ontype && cur[ ontype ];
< 			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
< 				event.result = handle.apply( cur, data );
< 				if ( event.result === false ) {
< 					event.preventDefault();
< 				}
< 			}
< 		}
< 		event.type = type;
< 
< 		// If nobody prevented the default action, do it now
< 		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
< 
< 			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
< 				jQuery.acceptData( elem ) ) {
< 
< 				// Call a native DOM method on the target with the same name name as the event.
< 				// Don't do default actions on window, that's where global variables be (#6170)
< 				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
< 
< 					// Don't re-trigger an onFOO event when we call its FOO() method
< 					tmp = elem[ ontype ];
< 
< 					if ( tmp ) {
< 						elem[ ontype ] = null;
< 					}
< 
< 					// Prevent re-triggering of the same event, since we already bubbled it above
< 					jQuery.event.triggered = type;
< 					elem[ type ]();
< 					jQuery.event.triggered = undefined;
< 
< 					if ( tmp ) {
< 						elem[ ontype ] = tmp;
< 					}
< 				}
< 			}
< 		}
< 
< 		return event.result;
< 	},
< 
< 	dispatch: function( event ) {
---
> 	dispatch: function( nativeEvent ) {
4399c5195
< 		event = jQuery.event.fix( event );
---
> 		var event = jQuery.event.fix( nativeEvent );
4401,4404c5197,5199
< 		var i, j, ret, matched, handleObj,
< 			handlerQueue = [],
< 			args = slice.call( arguments ),
< 			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
---
> 		var i, j, ret, matched, handleObj, handlerQueue,
> 			args = new Array( arguments.length ),
> 			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
4408c5203,5208
< 		args[0] = event;
---
> 		args[ 0 ] = event;
> 
> 		for ( i = 1; i < arguments.length; i++ ) {
> 			args[ i ] = arguments[ i ];
> 		}
> 
4421c5221
< 		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
---
> 		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
4425c5225,5226
< 			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {
---
> 			while ( ( handleObj = matched.handlers[ j++ ] ) &&
> 				!event.isImmediatePropagationStopped() ) {
4427,4429c5228,5231
< 				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
< 				// a subset or equal to those in the bound event (both can have no namespace).
< 				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {
---
> 				// If the event is namespaced, then each handler is only invoked if it is
> 				// specially universal or its namespaces are a superset of the event's.
> 				if ( !event.rnamespace || handleObj.namespace === false ||
> 					event.rnamespace.test( handleObj.namespace ) ) {
4434,4435c5236,5237
< 					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
< 							.apply( matched.elem, args );
---
> 					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
> 						handleObj.handler ).apply( matched.elem, args );
4438c5240
< 						if ( (event.result = ret) === false ) {
---
> 						if ( ( event.result = ret ) === false ) {
4456c5258
< 		var i, matches, sel, handleObj,
---
> 		var i, handleObj, sel, matchedHandlers, matchedSelectors,
4462,4464c5264,5275
< 		// Black-hole SVG <use> instance trees (#13180)
< 		// Avoid non-left-click bubbling in Firefox (#3861)
< 		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {
---
> 		if ( delegateCount &&
> 
> 			// Support: IE <=9
> 			// Black-hole SVG <use> instance trees (trac-13180)
> 			cur.nodeType &&
> 
> 			// Support: Firefox <=42
> 			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
> 			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
> 			// Support: IE 11 only
> 			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
> 			!( event.type === "click" && event.button >= 1 ) ) {
4467a5279
> 				// Don't check non-elements (#13208)
4469,4470c5281,5283
< 				if ( cur.disabled !== true || event.type !== "click" ) {
< 					matches = [];
---
> 				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
> 					matchedHandlers = [];
> 					matchedSelectors = {};
4477,4479c5290,5292
< 						if ( matches[ sel ] === undefined ) {
< 							matches[ sel ] = handleObj.needsContext ?
< 								jQuery( sel, this ).index( cur ) >= 0 :
---
> 						if ( matchedSelectors[ sel ] === undefined ) {
> 							matchedSelectors[ sel ] = handleObj.needsContext ?
> 								jQuery( sel, this ).index( cur ) > -1 :
4482,4483c5295,5296
< 						if ( matches[ sel ] ) {
< 							matches.push( handleObj );
---
> 						if ( matchedSelectors[ sel ] ) {
> 							matchedHandlers.push( handleObj );
4486,4487c5299,5300
< 					if ( matches.length ) {
< 						handlerQueue.push({ elem: cur, handlers: matches });
---
> 					if ( matchedHandlers.length ) {
> 						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
4493a5307
> 		cur = this;
4495c5309
< 			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
---
> 			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
4501,4513c5315,5330
< 	// Includes some event props shared by KeyEvent and MouseEvent
< 	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
< 
< 	fixHooks: {},
< 
< 	keyHooks: {
< 		props: "char charCode key keyCode".split(" "),
< 		filter: function( event, original ) {
< 
< 			// Add which for key events
< 			if ( event.which == null ) {
< 				event.which = original.charCode != null ? original.charCode : original.keyCode;
< 			}
---
> 	addProp: function( name, hook ) {
> 		Object.defineProperty( jQuery.Event.prototype, name, {
> 			enumerable: true,
> 			configurable: true,
> 
> 			get: isFunction( hook ) ?
> 				function() {
> 					if ( this.originalEvent ) {
> 							return hook( this.originalEvent );
> 					}
> 				} :
> 				function() {
> 					if ( this.originalEvent ) {
> 							return this.originalEvent[ name ];
> 					}
> 				},
4515,4516c5332,5340
< 			return event;
< 		}
---
> 			set: function( value ) {
> 				Object.defineProperty( this, name, {
> 					enumerable: true,
> 					configurable: true,
> 					writable: true,
> 					value: value
> 				} );
> 			}
> 		} );
4519,4542c5343,5346
< 	mouseHooks: {
< 		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
< 		filter: function( event, original ) {
< 			var eventDoc, doc, body,
< 				button = original.button;
< 
< 			// Calculate pageX/Y if missing and clientX/Y available
< 			if ( event.pageX == null && original.clientX != null ) {
< 				eventDoc = event.target.ownerDocument || document;
< 				doc = eventDoc.documentElement;
< 				body = eventDoc.body;
< 
< 				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
< 				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
< 			}
< 
< 			// Add which for click: 1 === left; 2 === middle; 3 === right
< 			// Note: button is not normalized, so don't use it
< 			if ( !event.which && button !== undefined ) {
< 				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
< 			}
< 
< 			return event;
< 		}
---
> 	fix: function( originalEvent ) {
> 		return originalEvent[ jQuery.expando ] ?
> 			originalEvent :
> 			new jQuery.Event( originalEvent );
4545,4548c5349,5350
< 	fix: function( event ) {
< 		if ( event[ jQuery.expando ] ) {
< 			return event;
< 		}
---
> 	special: {
> 		load: {
4550,4554c5352,5355
< 		// Create a writable copy of the event object and normalize some properties
< 		var i, prop, copy,
< 			type = event.type,
< 			originalEvent = event,
< 			fixHook = this.fixHooks[ type ];
---
> 			// Prevent triggered image.load events from bubbling to window.load
> 			noBubble: true
> 		},
> 		click: {
4556,4562c5357,5358
< 		if ( !fixHook ) {
< 			this.fixHooks[ type ] = fixHook =
< 				rmouseEvent.test( type ) ? this.mouseHooks :
< 				rkeyEvent.test( type ) ? this.keyHooks :
< 				{};
< 		}
< 		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;
---
> 			// Utilize native event to ensure correct state for checkable inputs
> 			setup: function( data ) {
4564c5360,5362
< 		event = new jQuery.Event( originalEvent );
---
> 				// For mutual compressibility with _default, replace `this` access with a local var.
> 				// `|| data` is dead code meant only to preserve the variable through minification.
> 				var el = this || data;
4566,4570c5364,5366
< 		i = copy.length;
< 		while ( i-- ) {
< 			prop = copy[ i ];
< 			event[ prop ] = originalEvent[ prop ];
< 		}
---
> 				// Claim the first handler
> 				if ( rcheckableType.test( el.type ) &&
> 					el.click && nodeName( el, "input" ) ) {
4572,4576c5368,5370
< 		// Support: Cordova 2.5 (WebKit) (#13255)
< 		// All events should have a target; Cordova deviceready doesn't
< 		if ( !event.target ) {
< 			event.target = document;
< 		}
---
> 					// dataPriv.set( el, "click", ... )
> 					leverageNative( el, "click", returnTrue );
> 				}
4578,4582c5372,5375
< 		// Support: Safari 6.0+, Chrome<28
< 		// Target should not be a text node (#504, #13143)
< 		if ( event.target.nodeType === 3 ) {
< 			event.target = event.target.parentNode;
< 		}
---
> 				// Return false to allow normal processing in the caller
> 				return false;
> 			},
> 			trigger: function( data ) {
4584,4585c5377,5379
< 		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
< 	},
---
> 				// For mutual compressibility with _default, replace `this` access with a local var.
> 				// `|| data` is dead code meant only to preserve the variable through minification.
> 				var el = this || data;
4587,4616c5381,5385
< 	special: {
< 		load: {
< 			// Prevent triggered image.load events from bubbling to window.load
< 			noBubble: true
< 		},
< 		focus: {
< 			// Fire native event if possible so blur/focus sequence is correct
< 			trigger: function() {
< 				if ( this !== safeActiveElement() && this.focus ) {
< 					this.focus();
< 					return false;
< 				}
< 			},
< 			delegateType: "focusin"
< 		},
< 		blur: {
< 			trigger: function() {
< 				if ( this === safeActiveElement() && this.blur ) {
< 					this.blur();
< 					return false;
< 				}
< 			},
< 			delegateType: "focusout"
< 		},
< 		click: {
< 			// For checkbox, fire native event so checked state will be right
< 			trigger: function() {
< 				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
< 					this.click();
< 					return false;
---
> 				// Force setup before triggering a click
> 				if ( rcheckableType.test( el.type ) &&
> 					el.click && nodeName( el, "input" ) ) {
> 
> 					leverageNative( el, "click" );
4617a5387,5389
> 
> 				// Return non-false to allow normal event-path propagation
> 				return true;
4620c5392,5393
< 			// For cross-browser consistency, don't fire native .click() on links
---
> 			// For cross-browser consistency, suppress native .click() on links
> 			// Also prevent it if we're currently inside a leveraged native-event stack
4622c5395,5399
< 				return jQuery.nodeName( event.target, "a" );
---
> 				var target = event.target;
> 				return rcheckableType.test( target.type ) &&
> 					target.click && nodeName( target, "input" ) &&
> 					dataPriv.get( target, "click" ) ||
> 					nodeName( target, "a" );
4636c5413,5414
< 	},
---
> 	}
> };
4638,4657c5416,5425
< 	simulate: function( type, elem, event, bubble ) {
< 		// Piggyback on a donor event to simulate a different one.
< 		// Fake originalEvent to avoid donor's stopPropagation, but if the
< 		// simulated event prevents default then we do the same on the donor.
< 		var e = jQuery.extend(
< 			new jQuery.Event(),
< 			event,
< 			{
< 				type: type,
< 				isSimulated: true,
< 				originalEvent: {}
< 			}
< 		);
< 		if ( bubble ) {
< 			jQuery.event.trigger( e, null, elem );
< 		} else {
< 			jQuery.event.dispatch.call( elem, e );
< 		}
< 		if ( e.isDefaultPrevented() ) {
< 			event.preventDefault();
---
> // Ensure the presence of an event listener that handles manually-triggered
> // synthetic events by interrupting progress until reinvoked in response to
> // *native* events that it fires directly, ensuring that state changes have
> // already occurred before other listeners are invoked.
> function leverageNative( el, type, expectSync ) {
> 
> 	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
> 	if ( !expectSync ) {
> 		if ( dataPriv.get( el, type ) === undefined ) {
> 			jQuery.event.add( el, type, returnTrue );
4658a5427
> 		return;
4660c5429,5501
< };
---
> 
> 	// Register the controller as a special universal handler for all event namespaces
> 	dataPriv.set( el, type, false );
> 	jQuery.event.add( el, type, {
> 		namespace: false,
> 		handler: function( event ) {
> 			var notAsync, result,
> 				saved = dataPriv.get( this, type );
> 
> 			if ( ( event.isTrigger & 1 ) && this[ type ] ) {
> 
> 				// Interrupt processing of the outer synthetic .trigger()ed event
> 				// Saved data should be false in such cases, but might be a leftover capture object
> 				// from an async native handler (gh-4350)
> 				if ( !saved.length ) {
> 
> 					// Store arguments for use when handling the inner native event
> 					// There will always be at least one argument (an event object), so this array
> 					// will not be confused with a leftover capture object.
> 					saved = slice.call( arguments );
> 					dataPriv.set( this, type, saved );
> 
> 					// Trigger the native event and capture its result
> 					// Support: IE <=9 - 11+
> 					// focus() and blur() are asynchronous
> 					notAsync = expectSync( this, type );
> 					this[ type ]();
> 					result = dataPriv.get( this, type );
> 					if ( saved !== result || notAsync ) {
> 						dataPriv.set( this, type, false );
> 					} else {
> 						result = {};
> 					}
> 					if ( saved !== result ) {
> 
> 						// Cancel the outer synthetic event
> 						event.stopImmediatePropagation();
> 						event.preventDefault();
> 						return result.value;
> 					}
> 
> 				// If this is an inner synthetic event for an event with a bubbling surrogate
> 				// (focus or blur), assume that the surrogate already propagated from triggering the
> 				// native event and prevent that from happening again here.
> 				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
> 				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
> 				// less bad than duplication.
> 				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
> 					event.stopPropagation();
> 				}
> 
> 			// If this is a native event triggered above, everything is now in order
> 			// Fire an inner synthetic event with the original arguments
> 			} else if ( saved.length ) {
> 
> 				// ...and capture the result
> 				dataPriv.set( this, type, {
> 					value: jQuery.event.trigger(
> 
> 						// Support: IE <=9 - 11+
> 						// Extend with the prototype to reset the above stopImmediatePropagation()
> 						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
> 						saved.slice( 1 ),
> 						this
> 					)
> 				} );
> 
> 				// Abort handling of the native event
> 				event.stopImmediatePropagation();
> 			}
> 		}
> 	} );
> }
4662a5504,5505
> 
> 	// This "if" is needed for plain objects
4664c5507
< 		elem.removeEventListener( type, handle, false );
---
> 		elem.removeEventListener( type, handle );
4668a5512
> 
4670c5514
< 	if ( !(this instanceof jQuery.Event) ) {
---
> 	if ( !( this instanceof jQuery.Event ) ) {
4683c5527,5528
< 				// Support: Android<4.0
---
> 
> 				// Support: Android <=2.3 only
4687a5533,5542
> 		// Create target properties
> 		// Support: Safari <=6 - 7 only
> 		// Target should not be a text node (#504, #13143)
> 		this.target = ( src.target && src.target.nodeType === 3 ) ?
> 			src.target.parentNode :
> 			src.target;
> 
> 		this.currentTarget = src.currentTarget;
> 		this.relatedTarget = src.relatedTarget;
> 
4699c5554
< 	this.timeStamp = src && src.timeStamp || jQuery.now();
---
> 	this.timeStamp = src && src.timeStamp || Date.now();
4706c5561
< // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
---
> // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
4707a5563
> 	constructor: jQuery.Event,
4710a5567
> 	isSimulated: false,
4717c5574
< 		if ( e && e.preventDefault ) {
---
> 		if ( e && !this.isSimulated ) {
4726c5583
< 		if ( e && e.stopPropagation ) {
---
> 		if ( e && !this.isSimulated ) {
4735c5592
< 		if ( e && e.stopImmediatePropagation ) {
---
> 		if ( e && !this.isSimulated ) {
4742a5600,5688
> // Includes all common event props including KeyEvent and MouseEvent specific props
> jQuery.each( {
> 	altKey: true,
> 	bubbles: true,
> 	cancelable: true,
> 	changedTouches: true,
> 	ctrlKey: true,
> 	detail: true,
> 	eventPhase: true,
> 	metaKey: true,
> 	pageX: true,
> 	pageY: true,
> 	shiftKey: true,
> 	view: true,
> 	"char": true,
> 	code: true,
> 	charCode: true,
> 	key: true,
> 	keyCode: true,
> 	button: true,
> 	buttons: true,
> 	clientX: true,
> 	clientY: true,
> 	offsetX: true,
> 	offsetY: true,
> 	pointerId: true,
> 	pointerType: true,
> 	screenX: true,
> 	screenY: true,
> 	targetTouches: true,
> 	toElement: true,
> 	touches: true,
> 
> 	which: function( event ) {
> 		var button = event.button;
> 
> 		// Add which for key events
> 		if ( event.which == null && rkeyEvent.test( event.type ) ) {
> 			return event.charCode != null ? event.charCode : event.keyCode;
> 		}
> 
> 		// Add which for click: 1 === left; 2 === middle; 3 === right
> 		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
> 			if ( button & 1 ) {
> 				return 1;
> 			}
> 
> 			if ( button & 2 ) {
> 				return 3;
> 			}
> 
> 			if ( button & 4 ) {
> 				return 2;
> 			}
> 
> 			return 0;
> 		}
> 
> 		return event.which;
> 	}
> }, jQuery.event.addProp );
> 
> jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
> 	jQuery.event.special[ type ] = {
> 
> 		// Utilize native event if possible so blur/focus sequence is correct
> 		setup: function() {
> 
> 			// Claim the first handler
> 			// dataPriv.set( this, "focus", ... )
> 			// dataPriv.set( this, "blur", ... )
> 			leverageNative( this, type, expectSync );
> 
> 			// Return false to allow normal processing in the caller
> 			return false;
> 		},
> 		trigger: function() {
> 
> 			// Force setup before trigger
> 			leverageNative( this, type );
> 
> 			// Return non-false to allow normal event-path propagation
> 			return true;
> 		},
> 
> 		delegateType: delegateType
> 	};
> } );
> 
4744,4745c5690,5697
< // Support: Chrome 15+
< jQuery.each({
---
> // so that event delegation works in jQuery.
> // Do the same for pointerenter/pointerleave and pointerover/pointerout
> //
> // Support: Safari 7 only
> // Safari sends mouseenter too often; see:
> // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
> // for the description of the bug (it existed in older Chrome versions as well).
> jQuery.each( {
4761c5713
< 			// For mousenter/leave call the handler if related is outside the target.
---
> 			// For mouseenter/leave call the handler if related is outside the target.
4763c5715
< 			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
---
> 			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
4771,4826c5723
< });
< 
< // Support: Firefox, Chrome, Safari
< // Create "bubbling" focus and blur events
< if ( !support.focusinBubbles ) {
< 	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {
< 
< 		// Attach a single capturing handler on the document while someone wants focusin/focusout
< 		var handler = function( event ) {
< 				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
< 			};
< 
< 		jQuery.event.special[ fix ] = {
< 			setup: function() {
< 				var doc = this.ownerDocument || this,
< 					attaches = data_priv.access( doc, fix );
< 
< 				if ( !attaches ) {
< 					doc.addEventListener( orig, handler, true );
< 				}
< 				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
< 			},
< 			teardown: function() {
< 				var doc = this.ownerDocument || this,
< 					attaches = data_priv.access( doc, fix ) - 1;
< 
< 				if ( !attaches ) {
< 					doc.removeEventListener( orig, handler, true );
< 					data_priv.remove( doc, fix );
< 
< 				} else {
< 					data_priv.access( doc, fix, attaches );
< 				}
< 			}
< 		};
< 	});
< }
< 
< jQuery.fn.extend({
< 
< 	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
< 		var origFn, type;
< 
< 		// Types can be a map of types/handlers
< 		if ( typeof types === "object" ) {
< 			// ( types-Object, selector, data )
< 			if ( typeof selector !== "string" ) {
< 				// ( types-Object, data )
< 				data = data || selector;
< 				selector = undefined;
< 			}
< 			for ( type in types ) {
< 				this.on( type, selector, data, types[ type ], one );
< 			}
< 			return this;
< 		}
---
> } );
4828,4848c5725
< 		if ( data == null && fn == null ) {
< 			// ( types, fn )
< 			fn = selector;
< 			data = selector = undefined;
< 		} else if ( fn == null ) {
< 			if ( typeof selector === "string" ) {
< 				// ( types, selector, fn )
< 				fn = data;
< 				data = undefined;
< 			} else {
< 				// ( types, data, fn )
< 				fn = data;
< 				data = selector;
< 				selector = undefined;
< 			}
< 		}
< 		if ( fn === false ) {
< 			fn = returnFalse;
< 		} else if ( !fn ) {
< 			return this;
< 		}
---
> jQuery.fn.extend( {
4850,4862c5727,5728
< 		if ( one === 1 ) {
< 			origFn = fn;
< 			fn = function( event ) {
< 				// Can use an empty set, since event contains the info
< 				jQuery().off( event );
< 				return origFn.apply( this, arguments );
< 			};
< 			// Use same guid so caller can remove using origFn
< 			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
< 		}
< 		return this.each( function() {
< 			jQuery.event.add( this, types, fn, data, selector );
< 		});
---
> 	on: function( types, selector, data, fn ) {
> 		return on( this, types, selector, data, fn );
4865c5731
< 		return this.on( types, selector, data, fn, 1 );
---
> 		return on( this, types, selector, data, fn, 1 );
4869a5736
> 
4873c5740,5742
< 				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
---
> 				handleObj.namespace ?
> 					handleObj.origType + "." + handleObj.namespace :
> 					handleObj.origType,
4879a5749
> 
4886a5757
> 
4894c5765
< 		return this.each(function() {
---
> 		return this.each( function() {
4896,4908c5767
< 		});
< 	},
< 
< 	trigger: function( type, data ) {
< 		return this.each(function() {
< 			jQuery.event.trigger( type, data, this );
< 		});
< 	},
< 	triggerHandler: function( type, data ) {
< 		var elem = this[0];
< 		if ( elem ) {
< 			return jQuery.event.trigger( type, data, elem, true );
< 		}
---
> 		} );
4910c5769
< });
---
> } );
4914,4933d5772
< 	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
< 	rtagName = /<([\w:]+)/,
< 	rhtml = /<|&#?\w+;/,
< 	rnoInnerhtml = /<(?:script|style|link)/i,
< 	// checked="checked" or checked
< 	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
< 	rscriptType = /^$|\/(?:java|ecma)script/i,
< 	rscriptTypeMasked = /^true\/(.*)/,
< 	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
< 
< 	// We have to close these tags to support XHTML (#13200)
< 	wrapMap = {
< 
< 		// Support: IE9
< 		option: [ 1, "<select multiple='multiple'>", "</select>" ],
< 
< 		thead: [ 1, "<table>", "</table>" ],
< 		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
< 		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
< 		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
4935,4936c5774
< 		_default: [ 0, "", "" ]
< 	};
---
> 	/* eslint-disable max-len */
4938,4939c5776,5777
< // Support: IE9
< wrapMap.optgroup = wrapMap.option;
---
> 	// See https://github.com/eslint/eslint/issues/3229
> 	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
4941,4942c5779,5788
< wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
< wrapMap.th = wrapMap.td;
---
> 	/* eslint-enable */
> 
> 	// Support: IE <=10 - 11, Edge 12 - 13 only
> 	// In IE/Edge using regex groups here causes severe slowdowns.
> 	// See https://connect.microsoft.com/IE/feedback/details/1736512/
> 	rnoInnerhtml = /<script|<style|<link/i,
> 
> 	// checked="checked" or checked
> 	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
> 	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
4944,4945c5790
< // Support: 1.x compatibility
< // Manipulating tables requires a tbody
---
> // Prefer a tbody over its parent table for containing new rows
4947,4948c5792,5793
< 	return jQuery.nodeName( elem, "table" ) &&
< 		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?
---
> 	if ( nodeName( elem, "table" ) &&
> 		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
4950,4952c5795,5798
< 		elem.getElementsByTagName("tbody")[0] ||
< 			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
< 		elem;
---
> 		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
> 	}
> 
> 	return elem;
4957c5803
< 	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
---
> 	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
4961,4964c5807,5808
< 	var match = rscriptTypeMasked.exec( elem.type );
< 
< 	if ( match ) {
< 		elem.type = match[ 1 ];
---
> 	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
> 		elem.type = elem.type.slice( 5 );
4966c5810
< 		elem.removeAttribute("type");
---
> 		elem.removeAttribute( "type" );
4972,4983d5815
< // Mark scripts as having already been evaluated
< function setGlobalEval( elems, refElements ) {
< 	var i = 0,
< 		l = elems.length;
< 
< 	for ( ; i < l; i++ ) {
< 		data_priv.set(
< 			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
< 		);
< 	}
< }
< 
4992,4994c5824,5826
< 	if ( data_priv.hasData( src ) ) {
< 		pdataOld = data_priv.access( src );
< 		pdataCur = data_priv.set( dest, pdataOld );
---
> 	if ( dataPriv.hasData( src ) ) {
> 		pdataOld = dataPriv.access( src );
> 		pdataCur = dataPriv.set( dest, pdataOld );
5010,5011c5842,5843
< 	if ( data_user.hasData( src ) ) {
< 		udataOld = data_user.access( src );
---
> 	if ( dataUser.hasData( src ) ) {
> 		udataOld = dataUser.access( src );
5014c5846
< 		data_user.set( dest, udataCur );
---
> 		dataUser.set( dest, udataCur );
5018,5027d5849
< function getAll( context, tag ) {
< 	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
< 			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
< 			[];
< 
< 	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
< 		jQuery.merge( [ context ], ret ) :
< 		ret;
< }
< 
5042c5864,5981
< jQuery.extend({
---
> function domManip( collection, args, callback, ignored ) {
> 
> 	// Flatten any nested arrays
> 	args = concat.apply( [], args );
> 
> 	var fragment, first, scripts, hasScripts, node, doc,
> 		i = 0,
> 		l = collection.length,
> 		iNoClone = l - 1,
> 		value = args[ 0 ],
> 		valueIsFunction = isFunction( value );
> 
> 	// We can't cloneNode fragments that contain checked, in WebKit
> 	if ( valueIsFunction ||
> 			( l > 1 && typeof value === "string" &&
> 				!support.checkClone && rchecked.test( value ) ) ) {
> 		return collection.each( function( index ) {
> 			var self = collection.eq( index );
> 			if ( valueIsFunction ) {
> 				args[ 0 ] = value.call( this, index, self.html() );
> 			}
> 			domManip( self, args, callback, ignored );
> 		} );
> 	}
> 
> 	if ( l ) {
> 		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
> 		first = fragment.firstChild;
> 
> 		if ( fragment.childNodes.length === 1 ) {
> 			fragment = first;
> 		}
> 
> 		// Require either new content or an interest in ignored elements to invoke the callback
> 		if ( first || ignored ) {
> 			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
> 			hasScripts = scripts.length;
> 
> 			// Use the original fragment for the last item
> 			// instead of the first because it can end up
> 			// being emptied incorrectly in certain situations (#8070).
> 			for ( ; i < l; i++ ) {
> 				node = fragment;
> 
> 				if ( i !== iNoClone ) {
> 					node = jQuery.clone( node, true, true );
> 
> 					// Keep references to cloned scripts for later restoration
> 					if ( hasScripts ) {
> 
> 						// Support: Android <=4.0 only, PhantomJS 1 only
> 						// push.apply(_, arraylike) throws on ancient WebKit
> 						jQuery.merge( scripts, getAll( node, "script" ) );
> 					}
> 				}
> 
> 				callback.call( collection[ i ], node, i );
> 			}
> 
> 			if ( hasScripts ) {
> 				doc = scripts[ scripts.length - 1 ].ownerDocument;
> 
> 				// Reenable scripts
> 				jQuery.map( scripts, restoreScript );
> 
> 				// Evaluate executable scripts on first document insertion
> 				for ( i = 0; i < hasScripts; i++ ) {
> 					node = scripts[ i ];
> 					if ( rscriptType.test( node.type || "" ) &&
> 						!dataPriv.access( node, "globalEval" ) &&
> 						jQuery.contains( doc, node ) ) {
> 
> 						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {
> 
> 							// Optional AJAX dependency, but won't run scripts if not present
> 							if ( jQuery._evalUrl && !node.noModule ) {
> 								jQuery._evalUrl( node.src, {
> 									nonce: node.nonce || node.getAttribute( "nonce" )
> 								} );
> 							}
> 						} else {
> 							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
> 						}
> 					}
> 				}
> 			}
> 		}
> 	}
> 
> 	return collection;
> }
> 
> function remove( elem, selector, keepData ) {
> 	var node,
> 		nodes = selector ? jQuery.filter( selector, elem ) : elem,
> 		i = 0;
> 
> 	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
> 		if ( !keepData && node.nodeType === 1 ) {
> 			jQuery.cleanData( getAll( node ) );
> 		}
> 
> 		if ( node.parentNode ) {
> 			if ( keepData && isAttached( node ) ) {
> 				setGlobalEval( getAll( node, "script" ) );
> 			}
> 			node.parentNode.removeChild( node );
> 		}
> 	}
> 
> 	return elem;
> }
> 
> jQuery.extend( {
> 	htmlPrefilter: function( html ) {
> 		return html.replace( rxhtmlTag, "<$1></$2>" );
> 	},
> 
5046c5985
< 			inPage = jQuery.contains( elem.ownerDocument, elem );
---
> 			inPage = isAttached( elem );
5052c5991
< 			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
---
> 			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
5085,5170d6023
< 	buildFragment: function( elems, context, scripts, selection ) {
< 		var elem, tmp, tag, wrap, contains, j,
< 			fragment = context.createDocumentFragment(),
< 			nodes = [],
< 			i = 0,
< 			l = elems.length;
< 
< 		for ( ; i < l; i++ ) {
< 			elem = elems[ i ];
< 
< 			if ( elem || elem === 0 ) {
< 
< 				// Add nodes directly
< 				if ( jQuery.type( elem ) === "object" ) {
< 					// Support: QtWebKit, PhantomJS
< 					// push.apply(_, arraylike) throws on ancient WebKit
< 					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
< 
< 				// Convert non-html into a text node
< 				} else if ( !rhtml.test( elem ) ) {
< 					nodes.push( context.createTextNode( elem ) );
< 
< 				// Convert html into DOM nodes
< 				} else {
< 					tmp = tmp || fragment.appendChild( context.createElement("div") );
< 
< 					// Deserialize a standard representation
< 					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
< 					wrap = wrapMap[ tag ] || wrapMap._default;
< 					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];
< 
< 					// Descend through wrappers to the right content
< 					j = wrap[ 0 ];
< 					while ( j-- ) {
< 						tmp = tmp.lastChild;
< 					}
< 
< 					// Support: QtWebKit, PhantomJS
< 					// push.apply(_, arraylike) throws on ancient WebKit
< 					jQuery.merge( nodes, tmp.childNodes );
< 
< 					// Remember the top-level container
< 					tmp = fragment.firstChild;
< 
< 					// Ensure the created nodes are orphaned (#12392)
< 					tmp.textContent = "";
< 				}
< 			}
< 		}
< 
< 		// Remove wrapper from fragment
< 		fragment.textContent = "";
< 
< 		i = 0;
< 		while ( (elem = nodes[ i++ ]) ) {
< 
< 			// #4087 - If origin and destination elements are the same, and this is
< 			// that element, do not do anything
< 			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
< 				continue;
< 			}
< 
< 			contains = jQuery.contains( elem.ownerDocument, elem );
< 
< 			// Append to fragment
< 			tmp = getAll( fragment.appendChild( elem ), "script" );
< 
< 			// Preserve script evaluation history
< 			if ( contains ) {
< 				setGlobalEval( tmp );
< 			}
< 
< 			// Capture executables
< 			if ( scripts ) {
< 				j = 0;
< 				while ( (elem = tmp[ j++ ]) ) {
< 					if ( rscriptType.test( elem.type || "" ) ) {
< 						scripts.push( elem );
< 					}
< 				}
< 			}
< 		}
< 
< 		return fragment;
< 	},
< 
5172c6025
< 		var data, elem, type, key,
---
> 		var data, elem, type,
5176,5180c6029,6031
< 		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
< 			if ( jQuery.acceptData( elem ) ) {
< 				key = elem[ data_priv.expando ];
< 
< 				if ( key && (data = data_priv.cache[ key ]) ) {
---
> 		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
> 			if ( acceptData( elem ) ) {
> 				if ( ( data = elem[ dataPriv.expando ] ) ) {
5192,5195c6043,6052
< 					if ( data_priv.cache[ key ] ) {
< 						// Discard any remaining `private` data
< 						delete data_priv.cache[ key ];
< 					}
---
> 
> 					// Support: Chrome <=35 - 45+
> 					// Assign undefined instead of using delete, see Data#remove
> 					elem[ dataPriv.expando ] = undefined;
> 				}
> 				if ( elem[ dataUser.expando ] ) {
> 
> 					// Support: Chrome <=35 - 45+
> 					// Assign undefined instead of using delete, see Data#remove
> 					elem[ dataUser.expando ] = undefined;
5198,5199d6054
< 			// Discard any remaining `user` data
< 			delete data_user.cache[ elem[ data_user.expando ] ];
5202c6057,6066
< });
---
> } );
> 
> jQuery.fn.extend( {
> 	detach: function( selector ) {
> 		return remove( this, selector, true );
> 	},
> 
> 	remove: function( selector ) {
> 		return remove( this, selector );
> 	},
5204d6067
< jQuery.fn.extend({
5209c6072
< 				this.empty().each(function() {
---
> 				this.empty().each( function() {
5213c6076
< 				});
---
> 				} );
5218c6081
< 		return this.domManip( arguments, function( elem ) {
---
> 		return domManip( this, arguments, function( elem ) {
5223c6086
< 		});
---
> 		} );
5227c6090
< 		return this.domManip( arguments, function( elem ) {
---
> 		return domManip( this, arguments, function( elem ) {
5232c6095
< 		});
---
> 		} );
5236c6099
< 		return this.domManip( arguments, function( elem ) {
---
> 		return domManip( this, arguments, function( elem ) {
5240c6103
< 		});
---
> 		} );
5244c6107
< 		return this.domManip( arguments, function( elem ) {
---
> 		return domManip( this, arguments, function( elem ) {
5248,5269c6111
< 		});
< 	},
< 
< 	remove: function( selector, keepData /* Internal Use Only */ ) {
< 		var elem,
< 			elems = selector ? jQuery.filter( selector, this ) : this,
< 			i = 0;
< 
< 		for ( ; (elem = elems[i]) != null; i++ ) {
< 			if ( !keepData && elem.nodeType === 1 ) {
< 				jQuery.cleanData( getAll( elem ) );
< 			}
< 
< 			if ( elem.parentNode ) {
< 				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
< 					setGlobalEval( getAll( elem, "script" ) );
< 				}
< 				elem.parentNode.removeChild( elem );
< 			}
< 		}
< 
< 		return this;
---
> 		} );
5276c6118
< 		for ( ; (elem = this[i]) != null; i++ ) {
---
> 		for ( ; ( elem = this[ i ] ) != null; i++ ) {
5294c6136
< 		return this.map(function() {
---
> 		return this.map( function() {
5296c6138
< 		});
---
> 		} );
5313c6155
< 				value = value.replace( rxhtmlTag, "<$1></$2>" );
---
> 				value = jQuery.htmlPrefilter( value );
5329c6171
< 				} catch( e ) {}
---
> 				} catch ( e ) {}
5339,5345c6181
< 		var arg = arguments[ 0 ];
< 
< 		// Make the changes, replacing each context element with the new content
< 		this.domManip( arguments, function( elem ) {
< 			arg = this.parentNode;
< 
< 			jQuery.cleanData( getAll( this ) );
---
> 		var ignored = [];
5347,5354c6183,6185
< 			if ( arg ) {
< 				arg.replaceChild( elem, this );
< 			}
< 		});
< 
< 		// Force removal if there was no new content (e.g., from empty arguments)
< 		return arg && (arg.length || arg.nodeType) ? this : this.remove();
< 	},
---
> 		// Make the changes, replacing each non-ignored context element with the new content
> 		return domManip( this, arguments, function( elem ) {
> 			var parent = this.parentNode;
5356,5438c6187,6190
< 	detach: function( selector ) {
< 		return this.remove( selector, true );
< 	},
< 
< 	domManip: function( args, callback ) {
< 
< 		// Flatten any nested arrays
< 		args = concat.apply( [], args );
< 
< 		var fragment, first, scripts, hasScripts, node, doc,
< 			i = 0,
< 			l = this.length,
< 			set = this,
< 			iNoClone = l - 1,
< 			value = args[ 0 ],
< 			isFunction = jQuery.isFunction( value );
< 
< 		// We can't cloneNode fragments that contain checked, in WebKit
< 		if ( isFunction ||
< 				( l > 1 && typeof value === "string" &&
< 					!support.checkClone && rchecked.test( value ) ) ) {
< 			return this.each(function( index ) {
< 				var self = set.eq( index );
< 				if ( isFunction ) {
< 					args[ 0 ] = value.call( this, index, self.html() );
< 				}
< 				self.domManip( args, callback );
< 			});
< 		}
< 
< 		if ( l ) {
< 			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
< 			first = fragment.firstChild;
< 
< 			if ( fragment.childNodes.length === 1 ) {
< 				fragment = first;
< 			}
< 
< 			if ( first ) {
< 				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
< 				hasScripts = scripts.length;
< 
< 				// Use the original fragment for the last item instead of the first because it can end up
< 				// being emptied incorrectly in certain situations (#8070).
< 				for ( ; i < l; i++ ) {
< 					node = fragment;
< 
< 					if ( i !== iNoClone ) {
< 						node = jQuery.clone( node, true, true );
< 
< 						// Keep references to cloned scripts for later restoration
< 						if ( hasScripts ) {
< 							// Support: QtWebKit
< 							// jQuery.merge because push.apply(_, arraylike) throws
< 							jQuery.merge( scripts, getAll( node, "script" ) );
< 						}
< 					}
< 
< 					callback.call( this[ i ], node, i );
< 				}
< 
< 				if ( hasScripts ) {
< 					doc = scripts[ scripts.length - 1 ].ownerDocument;
< 
< 					// Reenable scripts
< 					jQuery.map( scripts, restoreScript );
< 
< 					// Evaluate executable scripts on first document insertion
< 					for ( i = 0; i < hasScripts; i++ ) {
< 						node = scripts[ i ];
< 						if ( rscriptType.test( node.type || "" ) &&
< 							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {
< 
< 							if ( node.src ) {
< 								// Optional AJAX dependency, but won't run scripts if not present
< 								if ( jQuery._evalUrl ) {
< 									jQuery._evalUrl( node.src );
< 								}
< 							} else {
< 								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
< 							}
< 						}
< 					}
---
> 			if ( jQuery.inArray( this, ignored ) < 0 ) {
> 				jQuery.cleanData( getAll( this ) );
> 				if ( parent ) {
> 					parent.replaceChild( elem, this );
5441d6192
< 		}
5443c6194,6195
< 		return this;
---
> 		// Force callback invocation
> 		}, ignored );
5445c6197
< });
---
> } );
5447c6199
< jQuery.each({
---
> jQuery.each( {
5465,5466c6217,6218
< 			// Support: QtWebKit
< 			// .get() because push.apply(_, arraylike) throws
---
> 			// Support: Android <=4.0 only, PhantomJS 1 only
> 			// .get() because push.apply(_, arraylike) throws on ancient WebKit
5472,5473c6224,6225
< });
< 
---
> } );
> var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
5475,5476c6227
< var iframe,
< 	elemdisplay = {};
---
> var getStyles = function( elem ) {
5478,5497c6229,6232
< /**
<  * Retrieve the actual display of a element
<  * @param {String} name nodeName of the element
<  * @param {Object} doc Document object
<  */
< // Called only from within defaultDisplay
< function actualDisplay( name, doc ) {
< 	var style,
< 		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),
< 
< 		// getDefaultComputedStyle might be reliably used only on attached element
< 		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?
< 
< 			// Use of this method is a temporary fix (more like optimization) until something better comes along,
< 			// since it was removed from specification and supported only in FF
< 			style.display : jQuery.css( elem[ 0 ], "display" );
< 
< 	// We don't have any data stored on the element,
< 	// so use "detach" method as fast way to get rid of the element
< 	elem.detach();
---
> 		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
> 		// IE throws on elements created in popups
> 		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
> 		var view = elem.ownerDocument.defaultView;
5499,5500c6234,6236
< 	return display;
< }
---
> 		if ( !view || !view.opener ) {
> 			view = window;
> 		}
5502,5508c6238,6239
< /**
<  * Try to determine the default display value of an element
<  * @param {String} nodeName
<  */
< function defaultDisplay( nodeName ) {
< 	var doc = document,
< 		display = elemdisplay[ nodeName ];
---
> 		return view.getComputedStyle( elem );
> 	};
5510,5511c6241
< 	if ( !display ) {
< 		display = actualDisplay( nodeName, doc );
---
> var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );
5513,5514d6242
< 		// If the simple way fails, read from inside an iframe
< 		if ( display === "none" || !display ) {
5516,5517d6243
< 			// Use the already-created iframe if possible
< 			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );
5519,5520c6245
< 			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
< 			doc = iframe[ 0 ].contentDocument;
---
> ( function() {
5522,5524c6247,6249
< 			// Support: IE
< 			doc.write();
< 			doc.close();
---
> 	// Executing both pixelPosition & boxSizingReliable tests require only one layout
> 	// so they're executed at the same time to save the second computation.
> 	function computeStyleTests() {
5526,5527c6251,6253
< 			display = actualDisplay( nodeName, doc );
< 			iframe.detach();
---
> 		// This is a singleton, we need to execute it only once
> 		if ( !div ) {
> 			return;
5530,5531c6256,6290
< 		// Store the correct default display
< 		elemdisplay[ nodeName ] = display;
---
> 		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
> 			"margin-top:1px;padding:0;border:0";
> 		div.style.cssText =
> 			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
> 			"margin:auto;border:1px;padding:1px;" +
> 			"width:60%;top:1%";
> 		documentElement.appendChild( container ).appendChild( div );
> 
> 		var divStyle = window.getComputedStyle( div );
> 		pixelPositionVal = divStyle.top !== "1%";
> 
> 		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
> 		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;
> 
> 		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
> 		// Some styles come back with percentage values, even though they shouldn't
> 		div.style.right = "60%";
> 		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;
> 
> 		// Support: IE 9 - 11 only
> 		// Detect misreporting of content dimensions for box-sizing:border-box elements
> 		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;
> 
> 		// Support: IE 9 only
> 		// Detect overflow:scroll screwiness (gh-3699)
> 		// Support: Chrome <=64
> 		// Don't get tricked when zoom affects offsetWidth (gh-4029)
> 		div.style.position = "absolute";
> 		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;
> 
> 		documentElement.removeChild( container );
> 
> 		// Nullify the div so it wouldn't be stored in the memory and
> 		// it will also be a sign that checks already performed
> 		div = null;
5534,5536c6293,6295
< 	return display;
< }
< var rmargin = (/^margin/);
---
> 	function roundPixelMeasures( measure ) {
> 		return Math.round( parseFloat( measure ) );
> 	}
5538c6297,6300
< var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
---
> 	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
> 		reliableMarginLeftVal,
> 		container = document.createElement( "div" ),
> 		div = document.createElement( "div" );
5540,5546c6302,6305
< var getStyles = function( elem ) {
< 		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
< 		// IE throws on elements created in popups
< 		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
< 		if ( elem.ownerDocument.defaultView.opener ) {
< 			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
< 		}
---
> 	// Finish early in limited (non-browser) environments
> 	if ( !div.style ) {
> 		return;
> 	}
5548,5549c6307,6311
< 		return window.getComputedStyle( elem, null );
< 	};
---
> 	// Support: IE <=9 - 11 only
> 	// Style of cloned element affects source element cloned (#8908)
> 	div.style.backgroundClip = "content-box";
> 	div.cloneNode( true ).style.backgroundClip = "";
> 	support.clearCloneStyle = div.style.backgroundClip === "content-box";
5550a6313,6335
> 	jQuery.extend( support, {
> 		boxSizingReliable: function() {
> 			computeStyleTests();
> 			return boxSizingReliableVal;
> 		},
> 		pixelBoxStyles: function() {
> 			computeStyleTests();
> 			return pixelBoxStylesVal;
> 		},
> 		pixelPosition: function() {
> 			computeStyleTests();
> 			return pixelPositionVal;
> 		},
> 		reliableMarginLeft: function() {
> 			computeStyleTests();
> 			return reliableMarginLeftVal;
> 		},
> 		scrollboxSize: function() {
> 			computeStyleTests();
> 			return scrollboxSizeVal;
> 		}
> 	} );
> } )();
5554a6340,6344
> 
> 		// Support: Firefox 51+
> 		// Retrieving style before computed somehow
> 		// fixes an issue with getting wrong values
> 		// on detached elements
5559,5560c6349,6351
< 	// Support: IE9
< 	// getPropertyValue is only needed for .css('filter') (#12537)
---
> 	// getPropertyValue is needed for:
> 	//   .css('filter') (IE 9 only, #12537)
> 	//   .css('--customProperty) (#3144)
5563,5565d6353
< 	}
< 
< 	if ( computed ) {
5567c6355
< 		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
---
> 		if ( ret === "" && !isAttached( elem ) ) {
5571d6358
< 		// Support: iOS < 6
5573,5575c6360,6364
< 		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
< 		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
< 		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
---
> 		// Android Browser returns percentage for some values,
> 		// but width seems to be reliably pixels.
> 		// This is against the CSSOM draft spec:
> 		// https://drafts.csswg.org/cssom/#resolved-values
> 		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {
5594c6383,6384
< 		// Support: IE
---
> 
> 		// Support: IE <=9 - 11 only
5601a6392
> 
5605a6397
> 
5613c6405
< 			return (this.get = hookFn).apply( this, arguments );
---
> 			return ( this.get = hookFn ).apply( this, arguments );
5619,5694c6411,6413
< (function() {
< 	var pixelPositionVal, boxSizingReliableVal,
< 		docElem = document.documentElement,
< 		container = document.createElement( "div" ),
< 		div = document.createElement( "div" );
< 
< 	if ( !div.style ) {
< 		return;
< 	}
< 
< 	// Support: IE9-11+
< 	// Style of cloned element affects source element cloned (#8908)
< 	div.style.backgroundClip = "content-box";
< 	div.cloneNode( true ).style.backgroundClip = "";
< 	support.clearCloneStyle = div.style.backgroundClip === "content-box";
< 
< 	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
< 		"position:absolute";
< 	container.appendChild( div );
< 
< 	// Executing both pixelPosition & boxSizingReliable tests require only one layout
< 	// so they're executed at the same time to save the second computation.
< 	function computePixelPositionAndBoxSizingReliable() {
< 		div.style.cssText =
< 			// Support: Firefox<29, Android 2.3
< 			// Vendor-prefix box-sizing
< 			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
< 			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
< 			"border:1px;padding:1px;width:4px;position:absolute";
< 		div.innerHTML = "";
< 		docElem.appendChild( container );
< 
< 		var divStyle = window.getComputedStyle( div, null );
< 		pixelPositionVal = divStyle.top !== "1%";
< 		boxSizingReliableVal = divStyle.width === "4px";
< 
< 		docElem.removeChild( container );
< 	}
< 
< 	// Support: node.js jsdom
< 	// Don't assume that getComputedStyle is a property of the global object
< 	if ( window.getComputedStyle ) {
< 		jQuery.extend( support, {
< 			pixelPosition: function() {
< 
< 				// This test is executed only once but we still do memoizing
< 				// since we can use the boxSizingReliable pre-computing.
< 				// No need to check if the test was already performed, though.
< 				computePixelPositionAndBoxSizingReliable();
< 				return pixelPositionVal;
< 			},
< 			boxSizingReliable: function() {
< 				if ( boxSizingReliableVal == null ) {
< 					computePixelPositionAndBoxSizingReliable();
< 				}
< 				return boxSizingReliableVal;
< 			},
< 			reliableMarginRight: function() {
< 
< 				// Support: Android 2.3
< 				// Check if div with explicit width and no margin-right incorrectly
< 				// gets computed margin-right based on width of container. (#3333)
< 				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
< 				// This support function is only executed once so no memoizing is needed.
< 				var ret,
< 					marginDiv = div.appendChild( document.createElement( "div" ) );
< 
< 				// Reset CSS: box-sizing; display; margin; border; padding
< 				marginDiv.style.cssText = div.style.cssText =
< 					// Support: Firefox<29, Android 2.3
< 					// Vendor-prefix box-sizing
< 					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
< 					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
< 				marginDiv.style.marginRight = marginDiv.style.width = "0";
< 				div.style.width = "1px";
< 				docElem.appendChild( container );
---
> var cssPrefixes = [ "Webkit", "Moz", "ms" ],
> 	emptyStyle = document.createElement( "div" ).style,
> 	vendorProps = {};
5696c6415,6416
< 				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );
---
> // Return a vendor-prefixed property or undefined
> function vendorPropName( name ) {
5698,5699c6418,6420
< 				docElem.removeChild( container );
< 				div.removeChild( marginDiv );
---
> 	// Check for vendor prefixed names
> 	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
> 		i = cssPrefixes.length;
5701,5703c6422,6426
< 				return ret;
< 			}
< 		});
---
> 	while ( i-- ) {
> 		name = cssPrefixes[ i ] + capName;
> 		if ( name in emptyStyle ) {
> 			return name;
> 		}
5705c6428
< })();
---
> }
5706a6430,6432
> // Return a potentially-mapped jQuery.cssProps or vendor prefixed property
> function finalPropName( name ) {
> 	var final = jQuery.cssProps[ name ] || vendorProps[ name ];
5708,5716c6434,6435
< // A method for quickly swapping in/out CSS properties to get correct calculations.
< jQuery.swap = function( elem, options, callback, args ) {
< 	var ret, name,
< 		old = {};
< 
< 	// Remember the old values, and insert the new ones
< 	for ( name in options ) {
< 		old[ name ] = elem.style[ name ];
< 		elem.style[ name ] = options[ name ];
---
> 	if ( final ) {
> 		return final;
5718,5723c6437,6438
< 
< 	ret = callback.apply( elem, args || [] );
< 
< 	// Revert the old values
< 	for ( name in options ) {
< 		elem.style[ name ] = old[ name ];
---
> 	if ( name in emptyStyle ) {
> 		return name;
5725,5727c6440,6441
< 
< 	return ret;
< };
---
> 	return vendorProps[ name ] = vendorPropName( name ) || name;
> }
5731c6445,6447
< 	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
---
> 
> 	// Swappable if display is none or starts with table
> 	// except "table", "table-cell", or "table-caption"
5734,5736c6450
< 	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
< 	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),
< 
---
> 	rcustomProp = /^--/,
5741,5766c6455
< 	},
< 
< 	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];
< 
< // Return a css property mapped to a potentially vendor prefixed property
< function vendorPropName( style, name ) {
< 
< 	// Shortcut for names that are not vendor prefixed
< 	if ( name in style ) {
< 		return name;
< 	}
< 
< 	// Check for vendor prefixed names
< 	var capName = name[0].toUpperCase() + name.slice(1),
< 		origName = name,
< 		i = cssPrefixes.length;
< 
< 	while ( i-- ) {
< 		name = cssPrefixes[ i ] + capName;
< 		if ( name in style ) {
< 			return name;
< 		}
< 	}
< 
< 	return origName;
< }
---
> 	};
5769c6458,6461
< 	var matches = rnumsplit.exec( value );
---
> 
> 	// Any relative (+/-) values have already been
> 	// normalized at this point
> 	var matches = rcssNum.exec( value );
5770a6463
> 
5772c6465
< 		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
---
> 		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
5776,5781c6469,6472
< function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
< 	var i = extra === ( isBorderBox ? "border" : "content" ) ?
< 		// If we already have the right measurement, avoid augmentation
< 		4 :
< 		// Otherwise initialize for horizontal or vertical properties
< 		name === "width" ? 1 : 0,
---
> function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
> 	var i = dimension === "width" ? 1 : 0,
> 		extra = 0,
> 		delta = 0;
5783c6474,6477
< 		val = 0;
---
> 	// Adjustment may not be necessary
> 	if ( box === ( isBorderBox ? "border" : "content" ) ) {
> 		return 0;
> 	}
5786,5788c6480,6483
< 		// Both box models exclude margin, so add it if we want it
< 		if ( extra === "margin" ) {
< 			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
---
> 
> 		// Both box models exclude margin
> 		if ( box === "margin" ) {
> 			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
5791,5795c6486,6487
< 		if ( isBorderBox ) {
< 			// border-box includes padding, so remove it if we want content
< 			if ( extra === "content" ) {
< 				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
< 			}
---
> 		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
> 		if ( !isBorderBox ) {
5797,5799c6489,6498
< 			// At this point, extra isn't border nor margin, so remove border
< 			if ( extra !== "margin" ) {
< 				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
---
> 			// Add padding
> 			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
> 
> 			// For "border" or "margin", add border
> 			if ( box !== "padding" ) {
> 				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
> 
> 			// But still keep track of it otherwise
> 			} else {
> 				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
5800a6500,6502
> 
> 		// If we get here with a border-box (content + padding + border), we're seeking "content" or
> 		// "padding" or "margin"
5802,5803d6503
< 			// At this point, extra isn't content, so add padding
< 			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
5805,5807c6505,6512
< 			// At this point, extra isn't content nor padding, so add border
< 			if ( extra !== "padding" ) {
< 				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
---
> 			// For "content", subtract padding
> 			if ( box === "content" ) {
> 				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
> 			}
> 
> 			// For "content" or "padding", subtract border
> 			if ( box !== "margin" ) {
> 				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
5812c6517,6534
< 	return val;
---
> 	// Account for positive content-box scroll gutter when requested by providing computedVal
> 	if ( !isBorderBox && computedVal >= 0 ) {
> 
> 		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
> 		// Assuming integer scroll gutter, subtract the rest and round down
> 		delta += Math.max( 0, Math.ceil(
> 			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
> 			computedVal -
> 			delta -
> 			extra -
> 			0.5
> 
> 		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
> 		// Use an explicit zero to avoid NaN (gh-3964)
> 		) ) || 0;
> 	}
> 
> 	return delta;
5815c6537
< function getWidthOrHeight( elem, name, extra ) {
---
> function getWidthOrHeight( elem, dimension, extra ) {
5817,5821c6539,6540
< 	// Start with offset property, which is equivalent to the border-box value
< 	var valueIsBorderBox = true,
< 		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
< 		styles = getStyles( elem ),
< 		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
---
> 	// Start with computed style
> 	var styles = getStyles( elem ),
5823,5831c6542,6547
< 	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
< 	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
< 	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
< 	if ( val <= 0 || val == null ) {
< 		// Fall back to computed then uncomputed css if necessary
< 		val = curCSS( elem, name, styles );
< 		if ( val < 0 || val == null ) {
< 			val = elem.style[ name ];
< 		}
---
> 		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
> 		// Fake content-box until we know it's needed to know the true value.
> 		boxSizingNeeded = !support.boxSizingReliable() || extra,
> 		isBorderBox = boxSizingNeeded &&
> 			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
> 		valueIsBorderBox = isBorderBox,
5833,5834c6549,6555
< 		// Computed unit is not pixels. Stop here and return.
< 		if ( rnumnonpx.test(val) ) {
---
> 		val = curCSS( elem, dimension, styles ),
> 		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );
> 
> 	// Support: Firefox <=54
> 	// Return a confounding non-pixel value or feign ignorance, as appropriate.
> 	if ( rnumnonpx.test( val ) ) {
> 		if ( !extra ) {
5836a6558,6559
> 		val = "auto";
> 	}
5838,5841d6560
< 		// Check for style in case a browser which returns unreliable values
< 		// for getComputedStyle silently falls back to the reliable elem.style
< 		valueIsBorderBox = isBorderBox &&
< 			( support.boxSizingReliable() || val === elem.style[ name ] );
5843,5844c6562,6583
< 		// Normalize "", auto, and prepare for extra
< 		val = parseFloat( val ) || 0;
---
> 	// Fall back to offsetWidth/offsetHeight when value is "auto"
> 	// This happens for inline elements with no explicit setting (gh-3571)
> 	// Support: Android <=4.1 - 4.3 only
> 	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
> 	// Support: IE 9-11 only
> 	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
> 	// We use getClientRects() to check for hidden/disconnected.
> 	// In those cases, the computed value can be trusted to be border-box
> 	if ( ( !support.boxSizingReliable() && isBorderBox ||
> 		val === "auto" ||
> 		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
> 		elem.getClientRects().length ) {
> 
> 		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
> 
> 		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
> 		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
> 		// retrieved value as a content box dimension.
> 		valueIsBorderBox = offsetProp in elem;
> 		if ( valueIsBorderBox ) {
> 			val = elem[ offsetProp ];
> 		}
5847c6586,6589
< 	// Use the active box-sizing model to add/subtract irrelevant styles
---
> 	// Normalize "" and auto
> 	val = parseFloat( val ) || 0;
> 
> 	// Adjust for the element's box model
5849c6591
< 		augmentWidthOrHeight(
---
> 		boxModelAdjustment(
5851c6593
< 			name,
---
> 			dimension,
5854c6596,6599
< 			styles
---
> 			styles,
> 
> 			// Provide the current computed size to request scroll gutter calculation (gh-3589)
> 			val
5859,5910c6604
< function showHide( elements, show ) {
< 	var display, elem, hidden,
< 		values = [],
< 		index = 0,
< 		length = elements.length;
< 
< 	for ( ; index < length; index++ ) {
< 		elem = elements[ index ];
< 		if ( !elem.style ) {
< 			continue;
< 		}
< 
< 		values[ index ] = data_priv.get( elem, "olddisplay" );
< 		display = elem.style.display;
< 		if ( show ) {
< 			// Reset the inline display of this element to learn if it is
< 			// being hidden by cascaded rules or not
< 			if ( !values[ index ] && display === "none" ) {
< 				elem.style.display = "";
< 			}
< 
< 			// Set elements which have been overridden with display: none
< 			// in a stylesheet to whatever the default browser style is
< 			// for such an element
< 			if ( elem.style.display === "" && isHidden( elem ) ) {
< 				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
< 			}
< 		} else {
< 			hidden = isHidden( elem );
< 
< 			if ( display !== "none" || !hidden ) {
< 				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
< 			}
< 		}
< 	}
< 
< 	// Set the display of most of the elements in a second loop
< 	// to avoid the constant reflow
< 	for ( index = 0; index < length; index++ ) {
< 		elem = elements[ index ];
< 		if ( !elem.style ) {
< 			continue;
< 		}
< 		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
< 			elem.style.display = show ? values[ index ] || "" : "none";
< 		}
< 	}
< 
< 	return elements;
< }
< 
< jQuery.extend({
---
> jQuery.extend( {
5928a6623
> 		"animationIterationCount": true,
5933a6629,6635
> 		"gridArea": true,
> 		"gridColumn": true,
> 		"gridColumnEnd": true,
> 		"gridColumnStart": true,
> 		"gridRow": true,
> 		"gridRowEnd": true,
> 		"gridRowStart": true,
5945,5947c6647
< 	cssProps: {
< 		"float": "cssFloat"
< 	},
---
> 	cssProps: {},
5959c6659,6660
< 			origName = jQuery.camelCase( name ),
---
> 			origName = camelCase( name ),
> 			isCustomProp = rcustomProp.test( name ),
5962c6663,6668
< 		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );
---
> 		// Make sure that we're working with the right name. We don't
> 		// want to query the value if it is a CSS custom property
> 		// since they are user-defined.
> 		if ( !isCustomProp ) {
> 			name = finalPropName( origName );
> 		}
5972,5973c6678,6680
< 			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
< 				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
---
> 			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
> 				value = adjustCSS( elem, name, ret );
> 
5983,5985c6690,6694
< 			// If a number, add 'px' to the (except for certain CSS properties)
< 			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
< 				value += "px";
---
> 			// If a number was passed in, add the unit (except for certain CSS properties)
> 			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
> 			// "px" to a few hardcoded values.
> 			if ( type === "number" && !isCustomProp ) {
> 				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
5988d6696
< 			// Support: IE9-11+
5995,5996c6703,6710
< 			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
< 				style[ name ] = value;
---
> 			if ( !hooks || !( "set" in hooks ) ||
> 				( value = hooks.set( elem, value, extra ) ) !== undefined ) {
> 
> 				if ( isCustomProp ) {
> 					style.setProperty( name, value );
> 				} else {
> 					style[ name ] = value;
> 				}
5999a6714
> 
6001c6716,6718
< 			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
---
> 			if ( hooks && "get" in hooks &&
> 				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
> 
6012c6729,6730
< 			origName = jQuery.camelCase( name );
---
> 			origName = camelCase( name ),
> 			isCustomProp = rcustomProp.test( name );
6014,6015c6732,6737
< 		// Make sure that we're working with the right name
< 		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );
---
> 		// Make sure that we're working with the right name. We don't
> 		// want to modify the value if it is a CSS custom property
> 		// since they are user-defined.
> 		if ( !isCustomProp ) {
> 			name = finalPropName( origName );
> 		}
6038c6760
< 			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
---
> 			return extra === true || isFinite( num ) ? num || 0 : val;
6039a6762
> 
6042c6765
< });
---
> } );
6044,6045c6767,6768
< jQuery.each([ "height", "width" ], function( i, name ) {
< 	jQuery.cssHooks[ name ] = {
---
> jQuery.each( [ "height", "width" ], function( i, dimension ) {
> 	jQuery.cssHooks[ dimension ] = {
6051,6055c6774,6786
< 				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
< 					jQuery.swap( elem, cssShow, function() {
< 						return getWidthOrHeight( elem, name, extra );
< 					}) :
< 					getWidthOrHeight( elem, name, extra );
---
> 				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
> 
> 					// Support: Safari 8+
> 					// Table columns in Safari have non-zero offsetWidth & zero
> 					// getBoundingClientRect().width unless display is changed.
> 					// Support: IE <=11 only
> 					// Running getBoundingClientRect on a disconnected node
> 					// in IE throws an error.
> 					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
> 						swap( elem, cssShow, function() {
> 							return getWidthOrHeight( elem, dimension, extra );
> 						} ) :
> 						getWidthOrHeight( elem, dimension, extra );
6060,6065c6791,6801
< 			var styles = extra && getStyles( elem );
< 			return setPositiveNumber( elem, value, extra ?
< 				augmentWidthOrHeight(
< 					elem,
< 					name,
< 					extra,
---
> 			var matches,
> 				styles = getStyles( elem ),
> 
> 				// Only read styles.position if the test has a chance to fail
> 				// to avoid forcing a reflow.
> 				scrollboxSizeBuggy = !support.scrollboxSize() &&
> 					styles.position === "absolute",
> 
> 				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
> 				boxSizingNeeded = scrollboxSizeBuggy || extra,
> 				isBorderBox = boxSizingNeeded &&
6067,6069c6803,6832
< 					styles
< 				) : 0
< 			);
---
> 				subtract = extra ?
> 					boxModelAdjustment(
> 						elem,
> 						dimension,
> 						extra,
> 						isBorderBox,
> 						styles
> 					) :
> 					0;
> 
> 			// Account for unreliable border-box dimensions by comparing offset* to computed and
> 			// faking a content-box to get border and padding (gh-3699)
> 			if ( isBorderBox && scrollboxSizeBuggy ) {
> 				subtract -= Math.ceil(
> 					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
> 					parseFloat( styles[ dimension ] ) -
> 					boxModelAdjustment( elem, dimension, "border", false, styles ) -
> 					0.5
> 				);
> 			}
> 
> 			// Convert to pixels if value adjustment is needed
> 			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
> 				( matches[ 3 ] || "px" ) !== "px" ) {
> 
> 				elem.style[ dimension ] = value;
> 				value = jQuery.css( elem, dimension );
> 			}
> 
> 			return setPositiveNumber( elem, value, subtract );
6072c6835
< });
---
> } );
6074,6075c6837
< // Support: Android 2.3
< jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
---
> jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
6078,6079c6840,6845
< 			return jQuery.swap( elem, { "display": "inline-block" },
< 				curCSS, [ elem, "marginRight" ] );
---
> 			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
> 				elem.getBoundingClientRect().left -
> 					swap( elem, { marginLeft: 0 }, function() {
> 						return elem.getBoundingClientRect().left;
> 					} )
> 				) + "px";
6085c6851
< jQuery.each({
---
> jQuery.each( {
6096c6862
< 				parts = typeof value === "string" ? value.split(" ") : [ value ];
---
> 				parts = typeof value === "string" ? value.split( " " ) : [ value ];
6107c6873
< 	if ( !rmargin.test( prefix ) ) {
---
> 	if ( prefix !== "margin" ) {
6110c6876
< });
---
> } );
6112c6878
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
6119c6885
< 			if ( jQuery.isArray( name ) ) {
---
> 			if ( Array.isArray( name ) ) {
6134,6152d6899
< 	},
< 	show: function() {
< 		return showHide( this, true );
< 	},
< 	hide: function() {
< 		return showHide( this );
< 	},
< 	toggle: function( state ) {
< 		if ( typeof state === "boolean" ) {
< 			return state ? this.show() : this.hide();
< 		}
< 
< 		return this.each(function() {
< 			if ( isHidden( this ) ) {
< 				jQuery( this ).show();
< 			} else {
< 				jQuery( this ).hide();
< 			}
< 		});
6154c6901
< });
---
> } );
6167c6914
< 		this.easing = easing || "swing";
---
> 		this.easing = easing || jQuery.easing._default;
6213,6214c6960,6963
< 			if ( tween.elem[ tween.prop ] != null &&
< 				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
---
> 			// Use a property on the element directly when it is not a DOM element,
> 			// or when there is no matching style property that exists.
> 			if ( tween.elem.nodeType !== 1 ||
> 				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
6222a6972
> 
6226a6977
> 
6232c6983,6985
< 			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
---
> 			} else if ( tween.elem.nodeType === 1 && (
> 					jQuery.cssHooks[ tween.prop ] ||
> 					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
6241c6994
< // Support: IE9
---
> // Support: IE <=9 only
6257c7010,7011
< 	}
---
> 	},
> 	_default: "swing"
6262c7016
< // Back Compat <1.8 extension point
---
> // Back compat <1.8 extension point
6269c7023
< 	fxNow, timerId,
---
> 	fxNow, inProgress,
6271,6292c7025
< 	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
< 	rrun = /queueHooks$/,
< 	animationPrefilters = [ defaultPrefilter ],
< 	tweeners = {
< 		"*": [ function( prop, value ) {
< 			var tween = this.createTween( prop, value ),
< 				target = tween.cur(),
< 				parts = rfxnum.exec( value ),
< 				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
< 
< 				// Starting value computation is required for potential unit mismatches
< 				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
< 					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
< 				scale = 1,
< 				maxIterations = 20;
< 
< 			if ( start && start[ 3 ] !== unit ) {
< 				// Trust units reported by jQuery.css
< 				unit = unit || start[ 3 ];
< 
< 				// Make sure we update the tween properties later on
< 				parts = parts || [];
---
> 	rrun = /queueHooks$/;
6294,6319c7027,7033
< 				// Iteratively approximate from a nonzero starting point
< 				start = +target || 1;
< 
< 				do {
< 					// If previous iteration zeroed out, double until we get *something*.
< 					// Use string for doubling so we don't accidentally see scale as unchanged below
< 					scale = scale || ".5";
< 
< 					// Adjust and apply
< 					start = start / scale;
< 					jQuery.style( tween.elem, prop, start + unit );
< 
< 				// Update scale, tolerating zero or NaN from tween.cur(),
< 				// break the loop if scale is unchanged or perfect, or if we've just had enough
< 				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
< 			}
< 
< 			// Update tween properties
< 			if ( parts ) {
< 				start = tween.start = +start || +target || 0;
< 				tween.unit = unit;
< 				// If a +=/-= token was provided, we're doing a relative animation
< 				tween.end = parts[ 1 ] ?
< 					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
< 					+parts[ 2 ];
< 			}
---
> function schedule() {
> 	if ( inProgress ) {
> 		if ( document.hidden === false && window.requestAnimationFrame ) {
> 			window.requestAnimationFrame( schedule );
> 		} else {
> 			window.setTimeout( schedule, jQuery.fx.interval );
> 		}
6321,6323c7035,7037
< 			return tween;
< 		} ]
< 	};
---
> 		jQuery.fx.tick();
> 	}
> }
6327c7041
< 	setTimeout(function() {
---
> 	window.setTimeout( function() {
6329,6330c7043,7044
< 	});
< 	return ( fxNow = jQuery.now() );
---
> 	} );
> 	return ( fxNow = Date.now() );
6342c7056
< 	for ( ; i < 4 ; i += 2 - includeWidth ) {
---
> 	for ( ; i < 4; i += 2 - includeWidth ) {
6356c7070
< 		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
---
> 		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
6360c7074
< 		if ( (tween = collection[ index ].call( animation, prop, value )) ) {
---
> 		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
6369,6370c7083,7084
< 	/* jshint validthis: true */
< 	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
---
> 	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
> 		isBox = "width" in props || "height" in props,
6374,6375c7088,7089
< 		hidden = elem.nodeType && isHidden( elem ),
< 		dataShow = data_priv.get( elem, "fxshow" );
---
> 		hidden = elem.nodeType && isHiddenWithinTree( elem ),
> 		dataShow = dataPriv.get( elem, "fxshow" );
6377c7091
< 	// Handle queue: false promises
---
> 	// Queue-skipping animations hijack the fx hooks
6391c7105,7106
< 		anim.always(function() {
---
> 		anim.always( function() {
> 
6393c7108
< 			anim.always(function() {
---
> 			anim.always( function() {
6398,6429c7113,7114
< 			});
< 		});
< 	}
< 
< 	// Height/width overflow pass
< 	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
< 		// Make sure that nothing sneaks out
< 		// Record all 3 overflow attributes because IE9-10 do not
< 		// change the overflow attribute when overflowX and
< 		// overflowY are set to the same value
< 		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
< 
< 		// Set display property to inline-block for height/width
< 		// animations on inline elements that are having width/height animated
< 		display = jQuery.css( elem, "display" );
< 
< 		// Test default display if display is currently "none"
< 		checkDisplay = display === "none" ?
< 			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;
< 
< 		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
< 			style.display = "inline-block";
< 		}
< 	}
< 
< 	if ( opts.overflow ) {
< 		style.overflow = "hidden";
< 		anim.always(function() {
< 			style.overflow = opts.overflow[ 0 ];
< 			style.overflowX = opts.overflow[ 1 ];
< 			style.overflowY = opts.overflow[ 2 ];
< 		});
---
> 			} );
> 		} );
6432c7117
< 	// show/hide pass
---
> 	// Detect show/hide animations
6435c7120
< 		if ( rfxtypes.exec( value ) ) {
---
> 		if ( rfxtypes.test( value ) ) {
6440c7125,7126
< 				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
---
> 				// Pretend to be hidden if this is a "show" and
> 				// there is still data from a stopped show/hide
6442a7129,7130
> 
> 				// Ignore all other no-op show/hide data
6448,6451d7135
< 
< 		// Any non-fx value stops us from restoring the original display value
< 		} else {
< 			display = undefined;
6455,6462c7139,7143
< 	if ( !jQuery.isEmptyObject( orig ) ) {
< 		if ( dataShow ) {
< 			if ( "hidden" in dataShow ) {
< 				hidden = dataShow.hidden;
< 			}
< 		} else {
< 			dataShow = data_priv.access( elem, "fxshow", {} );
< 		}
---
> 	// Bail out if this is a no-op like .hide().hide()
> 	propTween = !jQuery.isEmptyObject( props );
> 	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
> 		return;
> 	}
6464,6466c7145,7157
< 		// Store state if its toggle - enables .stop().toggle() to "reverse"
< 		if ( toggle ) {
< 			dataShow.hidden = !hidden;
---
> 	// Restrict "overflow" and "display" styles during box animations
> 	if ( isBox && elem.nodeType === 1 ) {
> 
> 		// Support: IE <=9 - 11, Edge 12 - 15
> 		// Record all 3 overflow attributes because IE does not infer the shorthand
> 		// from identically-valued overflowX and overflowY and Edge just mirrors
> 		// the overflowX value there.
> 		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
> 
> 		// Identify a display type, preferring old show/hide data over the CSS cascade
> 		restoreDisplay = dataShow && dataShow.display;
> 		if ( restoreDisplay == null ) {
> 			restoreDisplay = dataPriv.get( elem, "display" );
6468,6473c7159,7170
< 		if ( hidden ) {
< 			jQuery( elem ).show();
< 		} else {
< 			anim.done(function() {
< 				jQuery( elem ).hide();
< 			});
---
> 		display = jQuery.css( elem, "display" );
> 		if ( display === "none" ) {
> 			if ( restoreDisplay ) {
> 				display = restoreDisplay;
> 			} else {
> 
> 				// Get nonempty value(s) by temporarily forcing visibility
> 				showHide( [ elem ], true );
> 				restoreDisplay = elem.style.display || restoreDisplay;
> 				display = jQuery.css( elem, "display" );
> 				showHide( [ elem ] );
> 			}
6475,6476d7171
< 		anim.done(function() {
< 			var prop;
6478,6480c7173,7187
< 			data_priv.remove( elem, "fxshow" );
< 			for ( prop in orig ) {
< 				jQuery.style( elem, prop, orig[ prop ] );
---
> 		// Animate inline elements as inline-block
> 		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
> 			if ( jQuery.css( elem, "float" ) === "none" ) {
> 
> 				// Restore the original display value at the end of pure show/hide animations
> 				if ( !propTween ) {
> 					anim.done( function() {
> 						style.display = restoreDisplay;
> 					} );
> 					if ( restoreDisplay == null ) {
> 						display = style.display;
> 						restoreDisplay = display === "none" ? "" : display;
> 					}
> 				}
> 				style.display = "inline-block";
6482,6484c7189,7199
< 		});
< 		for ( prop in orig ) {
< 			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
---
> 		}
> 	}
> 
> 	if ( opts.overflow ) {
> 		style.overflow = "hidden";
> 		anim.always( function() {
> 			style.overflow = opts.overflow[ 0 ];
> 			style.overflowX = opts.overflow[ 1 ];
> 			style.overflowY = opts.overflow[ 2 ];
> 		} );
> 	}
6486,6490c7201,7209
< 			if ( !( prop in dataShow ) ) {
< 				dataShow[ prop ] = tween.start;
< 				if ( hidden ) {
< 					tween.end = tween.start;
< 					tween.start = prop === "width" || prop === "height" ? 1 : 0;
---
> 	// Implement show/hide animations
> 	propTween = false;
> 	for ( prop in orig ) {
> 
> 		// General show/hide setup for this element animation
> 		if ( !propTween ) {
> 			if ( dataShow ) {
> 				if ( "hidden" in dataShow ) {
> 					hidden = dataShow.hidden;
6491a7211,7222
> 			} else {
> 				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
> 			}
> 
> 			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
> 			if ( toggle ) {
> 				dataShow.hidden = !hidden;
> 			}
> 
> 			// Show elements before animating them
> 			if ( hidden ) {
> 				showHide( [ elem ], true );
6492a7224,7239
> 
> 			/* eslint-disable no-loop-func */
> 
> 			anim.done( function() {
> 
> 			/* eslint-enable no-loop-func */
> 
> 				// The final step of a "hide" animation is actually hiding the element
> 				if ( !hidden ) {
> 					showHide( [ elem ] );
> 				}
> 				dataPriv.remove( elem, "fxshow" );
> 				for ( prop in orig ) {
> 					jQuery.style( elem, prop, orig[ prop ] );
> 				}
> 			} );
6495,6497c7242,7250
< 	// If this is a noop like .hide().hide(), restore an overwritten display value
< 	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
< 		style.display = display;
---
> 		// Per-property setup
> 		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
> 		if ( !( prop in dataShow ) ) {
> 			dataShow[ prop ] = propTween.start;
> 			if ( hidden ) {
> 				propTween.end = propTween.start;
> 				propTween.start = 0;
> 			}
> 		}
6506c7259
< 		name = jQuery.camelCase( index );
---
> 		name = camelCase( index );
6509c7262
< 		if ( jQuery.isArray( value ) ) {
---
> 		if ( Array.isArray( value ) ) {
6542c7295
< 		length = animationPrefilters.length,
---
> 		length = Animation.prefilters.length,
6543a7297
> 
6546c7300
< 		}),
---
> 		} ),
6553c7307,7308
< 				// Support: Android 2.3
---
> 
> 				// Support: Android 2.3 only
6560c7315
< 			for ( ; index < length ; index++ ) {
---
> 			for ( ; index < length; index++ ) {
6564c7319
< 			deferred.notifyWith( elem, [ animation, percent, remaining ]);
---
> 			deferred.notifyWith( elem, [ animation, percent, remaining ] );
6565a7321
> 			// If there's more to do, yield
6568,6570d7323
< 			} else {
< 				deferred.resolveWith( elem, [ animation ] );
< 				return false;
6571a7325,7333
> 
> 			// If this was an empty animation, synthesize a final progress notification
> 			if ( !length ) {
> 				deferred.notifyWith( elem, [ animation, 1, 0 ] );
> 			}
> 
> 			// Resolve the animation and report its conclusion
> 			deferred.resolveWith( elem, [ animation ] );
> 			return false;
6573c7335
< 		animation = deferred.promise({
---
> 		animation = deferred.promise( {
6576c7338,7341
< 			opts: jQuery.extend( true, { specialEasing: {} }, options ),
---
> 			opts: jQuery.extend( true, {
> 				specialEasing: {},
> 				easing: jQuery.easing._default
> 			}, options ),
6589a7355
> 
6597c7363
< 				for ( ; index < length ; index++ ) {
---
> 				for ( ; index < length; index++ ) {
6602a7369
> 					deferred.notifyWith( elem, [ animation, 1, 0 ] );
6609c7376
< 		}),
---
> 		} ),
6614,6615c7381,7382
< 	for ( ; index < length ; index++ ) {
< 		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
---
> 	for ( ; index < length; index++ ) {
> 		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
6616a7384,7387
> 			if ( isFunction( result.stop ) ) {
> 				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
> 					result.stop.bind( result );
> 			}
6623c7394
< 	if ( jQuery.isFunction( animation.opts.start ) ) {
---
> 	if ( isFunction( animation.opts.start ) ) {
6626a7398,7404
> 	// Attach callbacks from options
> 	animation
> 		.progress( animation.opts.progress )
> 		.done( animation.opts.done, animation.opts.complete )
> 		.fail( animation.opts.fail )
> 		.always( animation.opts.always );
> 
6632c7410
< 		})
---
> 		} )
6635,6639c7413
< 	// attach callbacks from options
< 	return animation.progress( animation.opts.progress )
< 		.done( animation.opts.done, animation.opts.complete )
< 		.fail( animation.opts.fail )
< 		.always( animation.opts.always );
---
> 	return animation;
6643a7418,7425
> 	tweeners: {
> 		"*": [ function( prop, value ) {
> 			var tween = this.createTween( prop, value );
> 			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
> 			return tween;
> 		} ]
> 	},
> 
6645c7427
< 		if ( jQuery.isFunction( props ) ) {
---
> 		if ( isFunction( props ) ) {
6649c7431
< 			props = props.split(" ");
---
> 			props = props.match( rnothtmlwhite );
6656c7438
< 		for ( ; index < length ; index++ ) {
---
> 		for ( ; index < length; index++ ) {
6658,6659c7440,7441
< 			tweeners[ prop ] = tweeners[ prop ] || [];
< 			tweeners[ prop ].unshift( callback );
---
> 			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
> 			Animation.tweeners[ prop ].unshift( callback );
6662a7445,7446
> 	prefilters: [ defaultPrefilter ],
> 
6665c7449
< 			animationPrefilters.unshift( callback );
---
> 			Animation.prefilters.unshift( callback );
6667c7451
< 			animationPrefilters.push( callback );
---
> 			Animation.prefilters.push( callback );
6670c7454
< });
---
> } );
6675c7459
< 			jQuery.isFunction( speed ) && speed,
---
> 			isFunction( speed ) && speed,
6677c7461
< 		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
---
> 		easing: fn && easing || easing && !isFunction( easing ) && easing
6680,6681c7464,7477
< 	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
< 		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
---
> 	// Go to the end state if fx are off
> 	if ( jQuery.fx.off ) {
> 		opt.duration = 0;
> 
> 	} else {
> 		if ( typeof opt.duration !== "number" ) {
> 			if ( opt.duration in jQuery.fx.speeds ) {
> 				opt.duration = jQuery.fx.speeds[ opt.duration ];
> 
> 			} else {
> 				opt.duration = jQuery.fx.speeds._default;
> 			}
> 		}
> 	}
6692c7488
< 		if ( jQuery.isFunction( opt.old ) ) {
---
> 		if ( isFunction( opt.old ) ) {
6704c7500
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
6708c7504
< 		return this.filter( isHidden ).css( "opacity", 0 ).show()
---
> 		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
6711c7507
< 			.end().animate({ opacity: to }, speed, easing, callback );
---
> 			.end().animate( { opacity: to }, speed, easing, callback );
6716a7513
> 
6721c7518
< 				if ( empty || data_priv.get( this, "finish" ) ) {
---
> 				if ( empty || dataPriv.get( this, "finish" ) ) {
6747c7544
< 		return this.each(function() {
---
> 		return this.each( function() {
6751c7548
< 				data = data_priv.get( this );
---
> 				data = dataPriv.get( this );
6766c7563,7565
< 				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
---
> 				if ( timers[ index ].elem === this &&
> 					( type == null || timers[ index ].queue === type ) ) {
> 
6779c7578
< 		});
---
> 		} );
6785c7584
< 		return this.each(function() {
---
> 		return this.each( function() {
6787c7586
< 				data = data_priv.get( this ),
---
> 				data = dataPriv.get( this ),
6820c7619
< 		});
---
> 		} );
6822c7621
< });
---
> } );
6824c7623
< jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
---
> jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
6831c7630
< });
---
> } );
6834,6837c7633,7636
< jQuery.each({
< 	slideDown: genFx("show"),
< 	slideUp: genFx("hide"),
< 	slideToggle: genFx("toggle"),
---
> jQuery.each( {
> 	slideDown: genFx( "show" ),
> 	slideUp: genFx( "hide" ),
> 	slideToggle: genFx( "toggle" ),
6845c7644
< });
---
> } );
6853c7652
< 	fxNow = jQuery.now();
---
> 	fxNow = Date.now();
6857c7656,7657
< 		// Checks the timer has not already been removed
---
> 
> 		// Run the timer and safely remove it when done (allowing for external removal)
6871,6875c7671
< 	if ( timer() ) {
< 		jQuery.fx.start();
< 	} else {
< 		jQuery.timers.pop();
< 	}
---
> 	jQuery.fx.start();
6879d7674
< 
6881,6882c7676,7677
< 	if ( !timerId ) {
< 		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
---
> 	if ( inProgress ) {
> 		return;
6883a7679,7681
> 
> 	inProgress = true;
> 	schedule();
6887,6888c7685
< 	clearInterval( timerId );
< 	timerId = null;
---
> 	inProgress = null;
6893a7691
> 
6900c7698
< // http://blindsignals.com/index.php/2009/07/jquery-delay/
---
> // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
6906c7704
< 		var timeout = setTimeout( next, time );
---
> 		var timeout = window.setTimeout( next, time );
6908c7706
< 			clearTimeout( timeout );
---
> 			window.clearTimeout( timeout );
6910c7708
< 	});
---
> 	} );
6914c7712
< (function() {
---
> ( function() {
6921c7719
< 	// Support: iOS<=5.1, Android<=4.2+
---
> 	// Support: Android <=4.3 only
6925c7723
< 	// Support: IE<=11+
---
> 	// Support: IE <=11 only
6929,6934c7727
< 	// Support: Android<=2.3
< 	// Options inside disabled selects are incorrectly marked as disabled
< 	select.disabled = true;
< 	support.optDisabled = !opt.disabled;
< 
< 	// Support: IE<=11+
---
> 	// Support: IE <=11 only
6940c7733
< })();
---
> } )();
6943c7736
< var nodeHook, boolHook,
---
> var boolHook,
6946c7739
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
6952c7745
< 		return this.each(function() {
---
> 		return this.each( function() {
6954c7747
< 		});
---
> 		} );
6956c7749
< });
---
> } );
6958c7751
< jQuery.extend({
---
> jQuery.extend( {
6960c7753
< 		var hooks, ret,
---
> 		var ret, hooks,
6963,6964c7756,7757
< 		// don't get/set attributes on text, comment and attribute nodes
< 		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
---
> 		// Don't get/set attributes on text, comment and attribute nodes
> 		if ( nType === 3 || nType === 8 || nType === 2 ) {
6969c7762
< 		if ( typeof elem.getAttribute === strundefined ) {
---
> 		if ( typeof elem.getAttribute === "undefined" ) {
6973c7766
< 		// All attributes are lowercase
---
> 		// Attribute hooks are determined by the lowercase version
6976,6978c7769,7770
< 			name = name.toLowerCase();
< 			hooks = jQuery.attrHooks[ name ] ||
< 				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
---
> 			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
> 				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
6982d7773
< 
6984a7776,7777
> 				return;
> 			}
6986c7779,7780
< 			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
---
> 			if ( hooks && "set" in hooks &&
> 				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
6988,6991d7781
< 
< 			} else {
< 				elem.setAttribute( name, value + "" );
< 				return value;
6994,7003c7784,7785
< 		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
< 			return ret;
< 
< 		} else {
< 			ret = jQuery.find.attr( elem, name );
< 
< 			// Non-existent attributes return null, we normalize to undefined
< 			return ret == null ?
< 				undefined :
< 				ret;
---
> 			elem.setAttribute( name, value + "" );
> 			return value;
7005,7010d7786
< 	},
< 
< 	removeAttr: function( elem, value ) {
< 		var name, propName,
< 			i = 0,
< 			attrNames = value && value.match( rnotwhite );
7012,7014c7788,7790
< 		if ( attrNames && elem.nodeType === 1 ) {
< 			while ( (name = attrNames[i++]) ) {
< 				propName = jQuery.propFix[ name ] || name;
---
> 		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
> 			return ret;
> 		}
7016,7020c7792
< 				// Boolean attributes get special treatment (#10870)
< 				if ( jQuery.expr.match.bool.test( name ) ) {
< 					// Set corresponding property to false
< 					elem[ propName ] = false;
< 				}
---
> 		ret = jQuery.find.attr( elem, name );
7022,7024c7794,7795
< 				elem.removeAttribute( name );
< 			}
< 		}
---
> 		// Non-existent attributes return null, we normalize to undefined
> 		return ret == null ? undefined : ret;
7031c7802
< 					jQuery.nodeName( elem, "input" ) ) {
---
> 					nodeName( elem, "input" ) ) {
7040a7812,7826
> 	},
> 
> 	removeAttr: function( elem, value ) {
> 		var name,
> 			i = 0,
> 
> 			// Attribute names can contain non-HTML whitespace characters
> 			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
> 			attrNames = value && value.match( rnothtmlwhite );
> 
> 		if ( attrNames && elem.nodeType === 1 ) {
> 			while ( ( name = attrNames[ i++ ] ) ) {
> 				elem.removeAttribute( name );
> 			}
> 		}
7042c7828
< });
---
> } );
7047a7834
> 
7055a7843
> 
7060c7848,7850
< 		var ret, handle;
---
> 		var ret, handle,
> 			lowercaseName = name.toLowerCase();
> 
7061a7852
> 
7063,7064c7854,7855
< 			handle = attrHandle[ name ];
< 			attrHandle[ name ] = ret;
---
> 			handle = attrHandle[ lowercaseName ];
> 			attrHandle[ lowercaseName ] = ret;
7066c7857
< 				name.toLowerCase() :
---
> 				lowercaseName :
7068c7859
< 			attrHandle[ name ] = handle;
---
> 			attrHandle[ lowercaseName ] = handle;
7072c7863
< });
---
> } );
7077c7868,7869
< var rfocusable = /^(?:input|select|textarea|button)$/i;
---
> var rfocusable = /^(?:input|select|textarea|button)$/i,
> 	rclickable = /^(?:a|area)$/i;
7079c7871
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
7085c7877
< 		return this.each(function() {
---
> 		return this.each( function() {
7087c7879
< 		});
---
> 		} );
7089,7095c7881
< });
< 
< jQuery.extend({
< 	propFix: {
< 		"for": "htmlFor",
< 		"class": "className"
< 	},
---
> } );
7096a7883
> jQuery.extend( {
7098c7885
< 		var ret, hooks, notxml,
---
> 		var ret, hooks,
7102c7889
< 		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
---
> 		if ( nType === 3 || nType === 8 || nType === 2 ) {
7106c7893
< 		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );
---
> 		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
7108d7894
< 		if ( notxml ) {
7115,7117c7901,7904
< 			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
< 				ret :
< 				( elem[ name ] = value );
---
> 			if ( hooks && "set" in hooks &&
> 				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
> 				return ret;
> 			}
7119,7122c7906
< 		} else {
< 			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
< 				ret :
< 				elem[ name ];
---
> 			return ( elem[ name ] = value );
7123a7908,7913
> 
> 		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
> 			return ret;
> 		}
> 
> 		return elem[ name ];
7129,7131c7919,7939
< 				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
< 					elem.tabIndex :
< 					-1;
---
> 
> 				// Support: IE <=9 - 11 only
> 				// elem.tabIndex doesn't always return the
> 				// correct value when it hasn't been explicitly set
> 				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
> 				// Use proper attribute retrieval(#12072)
> 				var tabindex = jQuery.find.attr( elem, "tabindex" );
> 
> 				if ( tabindex ) {
> 					return parseInt( tabindex, 10 );
> 				}
> 
> 				if (
> 					rfocusable.test( elem.nodeName ) ||
> 					rclickable.test( elem.nodeName ) &&
> 					elem.href
> 				) {
> 					return 0;
> 				}
> 
> 				return -1;
7133a7942,7946
> 	},
> 
> 	propFix: {
> 		"for": "htmlFor",
> 		"class": "className"
7135c7948
< });
---
> } );
7136a7950,7957
> // Support: IE <=11 only
> // Accessing the selectedIndex property
> // forces the browser to respect setting selected
> // on the option
> // The getter ensures a default option is selected
> // when in an optgroup
> // eslint rule "no-unused-expressions" is disabled for this code
> // since it considers such accessions noop
7139a7961,7963
> 
> 			/* eslint no-unused-expressions: "off" */
> 
7144a7969,7981
> 		},
> 		set: function( elem ) {
> 
> 			/* eslint no-unused-expressions: "off" */
> 
> 			var parent = elem.parentNode;
> 			if ( parent ) {
> 				parent.selectedIndex;
> 
> 				if ( parent.parentNode ) {
> 					parent.parentNode.selectedIndex;
> 				}
> 			}
7149c7986
< jQuery.each([
---
> jQuery.each( [
7162c7999,8002
< });
---
> } );
> 
> 
> 
7163a8004,8009
> 	// Strip and collapse whitespace according to HTML spec
> 	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
> 	function stripAndCollapse( value ) {
> 		var tokens = value.match( rnothtmlwhite ) || [];
> 		return tokens.join( " " );
> 	}
7165a8012,8014
> function getClass( elem ) {
> 	return elem.getAttribute && elem.getAttribute( "class" ) || "";
> }
7167c8016,8024
< var rclass = /[\t\r\n\f]/g;
---
> function classesToArray( value ) {
> 	if ( Array.isArray( value ) ) {
> 		return value;
> 	}
> 	if ( typeof value === "string" ) {
> 		return value.match( rnothtmlwhite ) || [];
> 	}
> 	return [];
> }
7169c8026
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
7171,7174c8028,8029
< 		var classes, elem, cur, clazz, j, finalValue,
< 			proceed = typeof value === "string" && value,
< 			i = 0,
< 			len = this.length;
---
> 		var classes, elem, cur, curValue, clazz, j, finalValue,
> 			i = 0;
7176,7179c8031,8034
< 		if ( jQuery.isFunction( value ) ) {
< 			return this.each(function( j ) {
< 				jQuery( this ).addClass( value.call( this, j, this.className ) );
< 			});
---
> 		if ( isFunction( value ) ) {
> 			return this.each( function( j ) {
> 				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
> 			} );
7182,7191c8037,8042
< 		if ( proceed ) {
< 			// The disjunction here is for better compressibility (see removeClass)
< 			classes = ( value || "" ).match( rnotwhite ) || [];
< 
< 			for ( ; i < len; i++ ) {
< 				elem = this[ i ];
< 				cur = elem.nodeType === 1 && ( elem.className ?
< 					( " " + elem.className + " " ).replace( rclass, " " ) :
< 					" "
< 				);
---
> 		classes = classesToArray( value );
> 
> 		if ( classes.length ) {
> 			while ( ( elem = this[ i++ ] ) ) {
> 				curValue = getClass( elem );
> 				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
7195c8046
< 					while ( (clazz = classes[j++]) ) {
---
> 					while ( ( clazz = classes[ j++ ] ) ) {
7201,7204c8052,8055
< 					// only assign if different to avoid unneeded rendering.
< 					finalValue = jQuery.trim( cur );
< 					if ( elem.className !== finalValue ) {
< 						elem.className = finalValue;
---
> 					// Only assign if different to avoid unneeded rendering.
> 					finalValue = stripAndCollapse( cur );
> 					if ( curValue !== finalValue ) {
> 						elem.setAttribute( "class", finalValue );
7214,7217c8065,8066
< 		var classes, elem, cur, clazz, j, finalValue,
< 			proceed = arguments.length === 0 || typeof value === "string" && value,
< 			i = 0,
< 			len = this.length;
---
> 		var classes, elem, cur, curValue, clazz, j, finalValue,
> 			i = 0;
7219,7222c8068,8071
< 		if ( jQuery.isFunction( value ) ) {
< 			return this.each(function( j ) {
< 				jQuery( this ).removeClass( value.call( this, j, this.className ) );
< 			});
---
> 		if ( isFunction( value ) ) {
> 			return this.each( function( j ) {
> 				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
> 			} );
7224,7225d8072
< 		if ( proceed ) {
< 			classes = ( value || "" ).match( rnotwhite ) || [];
7227,7228c8074,8083
< 			for ( ; i < len; i++ ) {
< 				elem = this[ i ];
---
> 		if ( !arguments.length ) {
> 			return this.attr( "class", "" );
> 		}
> 
> 		classes = classesToArray( value );
> 
> 		if ( classes.length ) {
> 			while ( ( elem = this[ i++ ] ) ) {
> 				curValue = getClass( elem );
> 
7230,7233c8085
< 				cur = elem.nodeType === 1 && ( elem.className ?
< 					( " " + elem.className + " " ).replace( rclass, " " ) :
< 					""
< 				);
---
> 				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
7237c8089,8090
< 					while ( (clazz = classes[j++]) ) {
---
> 					while ( ( clazz = classes[ j++ ] ) ) {
> 
7239c8092
< 						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
---
> 						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
7245,7247c8098,8100
< 					finalValue = value ? jQuery.trim( cur ) : "";
< 					if ( elem.className !== finalValue ) {
< 						elem.className = finalValue;
---
> 					finalValue = stripAndCollapse( cur );
> 					if ( curValue !== finalValue ) {
> 						elem.setAttribute( "class", finalValue );
7257c8110,8111
< 		var type = typeof value;
---
> 		var type = typeof value,
> 			isValidValue = type === "string" || Array.isArray( value );
7259c8113
< 		if ( typeof stateVal === "boolean" && type === "string" ) {
---
> 		if ( typeof stateVal === "boolean" && isValidValue ) {
7263,7266c8117,8123
< 		if ( jQuery.isFunction( value ) ) {
< 			return this.each(function( i ) {
< 				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
< 			});
---
> 		if ( isFunction( value ) ) {
> 			return this.each( function( i ) {
> 				jQuery( this ).toggleClass(
> 					value.call( this, i, getClass( this ), stateVal ),
> 					stateVal
> 				);
> 			} );
7269,7270c8126,8130
< 		return this.each(function() {
< 			if ( type === "string" ) {
---
> 		return this.each( function() {
> 			var className, i, self, classNames;
> 
> 			if ( isValidValue ) {
> 
7272,7275c8132,8136
< 				var className,
< 					i = 0,
< 					self = jQuery( this ),
< 					classNames = value.match( rnotwhite ) || [];
---
> 				i = 0;
> 				self = jQuery( this );
> 				classNames = classesToArray( value );
> 
> 				while ( ( className = classNames[ i++ ] ) ) {
7277d8137
< 				while ( (className = classNames[ i++ ]) ) {
7287,7290c8147,8152
< 			} else if ( type === strundefined || type === "boolean" ) {
< 				if ( this.className ) {
< 					// store className if set
< 					data_priv.set( this, "__className__", this.className );
---
> 			} else if ( value === undefined || type === "boolean" ) {
> 				className = getClass( this );
> 				if ( className ) {
> 
> 					// Store className if set
> 					dataPriv.set( this, "__className__", className );
7297c8159,8165
< 				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
---
> 				if ( this.setAttribute ) {
> 					this.setAttribute( "class",
> 						className || value === false ?
> 						"" :
> 						dataPriv.get( this, "__className__" ) || ""
> 					);
> 				}
7299c8167
< 		});
---
> 		} );
7303,7308c8171,8178
< 		var className = " " + selector + " ",
< 			i = 0,
< 			l = this.length;
< 		for ( ; i < l; i++ ) {
< 			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
< 				return true;
---
> 		var className, elem,
> 			i = 0;
> 
> 		className = " " + selector + " ";
> 		while ( ( elem = this[ i++ ] ) ) {
> 			if ( elem.nodeType === 1 &&
> 				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
> 					return true;
7314c8184
< });
---
> } );
7321c8191
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
7323,7324c8193,8194
< 		var hooks, ret, isFunction,
< 			elem = this[0];
---
> 		var hooks, ret, valueIsFunction,
> 			elem = this[ 0 ];
7328c8198,8199
< 				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];
---
> 				hooks = jQuery.valHooks[ elem.type ] ||
> 					jQuery.valHooks[ elem.nodeName.toLowerCase() ];
7330c8201,8204
< 				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
---
> 				if ( hooks &&
> 					"get" in hooks &&
> 					( ret = hooks.get( elem, "value" ) ) !== undefined
> 				) {
7336,7340c8210,8216
< 				return typeof ret === "string" ?
< 					// Handle most common string cases
< 					ret.replace(rreturn, "") :
< 					// Handle cases where value is null/undef or number
< 					ret == null ? "" : ret;
---
> 				// Handle most common string cases
> 				if ( typeof ret === "string" ) {
> 					return ret.replace( rreturn, "" );
> 				}
> 
> 				// Handle cases where value is null/undef or number
> 				return ret == null ? "" : ret;
7346c8222
< 		isFunction = jQuery.isFunction( value );
---
> 		valueIsFunction = isFunction( value );
7348c8224
< 		return this.each(function( i ) {
---
> 		return this.each( function( i ) {
7355c8231
< 			if ( isFunction ) {
---
> 			if ( valueIsFunction ) {
7368c8244
< 			} else if ( jQuery.isArray( val ) ) {
---
> 			} else if ( Array.isArray( val ) ) {
7371c8247
< 				});
---
> 				} );
7377c8253
< 			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
---
> 			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
7380c8256
< 		});
---
> 		} );
7382c8258
< });
---
> } );
7384c8260
< jQuery.extend({
---
> jQuery.extend( {
7387a8264
> 
7391c8268,8269
< 					// Support: IE10-11+
---
> 
> 					// Support: IE <=10 - 11 only
7393c8271,8273
< 					jQuery.trim( jQuery.text( elem ) );
---
> 					// Strip and collapse whitespace
> 					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
> 					stripAndCollapse( jQuery.text( elem ) );
7398c8278
< 				var value, option,
---
> 				var value, option, i,
7401c8281
< 					one = elem.type === "select-one" || index < 0,
---
> 					one = elem.type === "select-one",
7403,7406c8283,8290
< 					max = one ? index + 1 : options.length,
< 					i = index < 0 ?
< 						max :
< 						one ? index : 0;
---
> 					max = one ? index + 1 : options.length;
> 
> 				if ( index < 0 ) {
> 					i = max;
> 
> 				} else {
> 					i = one ? index : 0;
> 				}
7412c8296,8297
< 					// IE6-9 doesn't update selected after form reset (#2551)
---
> 					// Support: IE <=9 only
> 					// IE8-9 doesn't update selected after form reset (#2551)
7413a8299
> 
7415,7416c8301,8303
< 							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
< 							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {
---
> 							!option.disabled &&
> 							( !option.parentNode.disabled ||
> 								!nodeName( option.parentNode, "optgroup" ) ) ) {
7442c8329,8334
< 					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
---
> 
> 					/* eslint-disable no-cond-assign */
> 
> 					if ( option.selected =
> 						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
> 					) {
7444a8337,8338
> 
> 					/* eslint-enable no-cond-assign */
7455c8349
< });
---
> } );
7458c8352
< jQuery.each([ "radio", "checkbox" ], function() {
---
> jQuery.each( [ "radio", "checkbox" ], function() {
7461,7462c8355,8356
< 			if ( jQuery.isArray( value ) ) {
< 				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
---
> 			if ( Array.isArray( value ) ) {
> 				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
7468c8362
< 			return elem.getAttribute("value") === null ? "on" : elem.value;
---
> 			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
7471c8365
< });
---
> } );
7479,7481c8373
< jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
< 	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
< 	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {
---
> support.focusin = "onfocusin" in window;
7483,7487c8375,8378
< 	// Handle event binding
< 	jQuery.fn[ name ] = function( data, fn ) {
< 		return arguments.length > 0 ?
< 			this.on( name, null, data, fn ) :
< 			this.trigger( name );
---
> 
> var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
> 	stopPropagationCallback = function( e ) {
> 		e.stopPropagation();
7489d8379
< });
7491,7494c8381
< jQuery.fn.extend({
< 	hover: function( fnOver, fnOut ) {
< 		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
< 	},
---
> jQuery.extend( jQuery.event, {
7496,7500c8383,8525
< 	bind: function( types, data, fn ) {
< 		return this.on( types, null, data, fn );
< 	},
< 	unbind: function( types, fn ) {
< 		return this.off( types, null, fn );
---
> 	trigger: function( event, data, elem, onlyHandlers ) {
> 
> 		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
> 			eventPath = [ elem || document ],
> 			type = hasOwn.call( event, "type" ) ? event.type : event,
> 			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
> 
> 		cur = lastElement = tmp = elem = elem || document;
> 
> 		// Don't do events on text and comment nodes
> 		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
> 			return;
> 		}
> 
> 		// focus/blur morphs to focusin/out; ensure we're not firing them right now
> 		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
> 			return;
> 		}
> 
> 		if ( type.indexOf( "." ) > -1 ) {
> 
> 			// Namespaced trigger; create a regexp to match event type in handle()
> 			namespaces = type.split( "." );
> 			type = namespaces.shift();
> 			namespaces.sort();
> 		}
> 		ontype = type.indexOf( ":" ) < 0 && "on" + type;
> 
> 		// Caller can pass in a jQuery.Event object, Object, or just an event type string
> 		event = event[ jQuery.expando ] ?
> 			event :
> 			new jQuery.Event( type, typeof event === "object" && event );
> 
> 		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
> 		event.isTrigger = onlyHandlers ? 2 : 3;
> 		event.namespace = namespaces.join( "." );
> 		event.rnamespace = event.namespace ?
> 			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
> 			null;
> 
> 		// Clean up the event in case it is being reused
> 		event.result = undefined;
> 		if ( !event.target ) {
> 			event.target = elem;
> 		}
> 
> 		// Clone any incoming data and prepend the event, creating the handler arg list
> 		data = data == null ?
> 			[ event ] :
> 			jQuery.makeArray( data, [ event ] );
> 
> 		// Allow special events to draw outside the lines
> 		special = jQuery.event.special[ type ] || {};
> 		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
> 			return;
> 		}
> 
> 		// Determine event propagation path in advance, per W3C events spec (#9951)
> 		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
> 		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {
> 
> 			bubbleType = special.delegateType || type;
> 			if ( !rfocusMorph.test( bubbleType + type ) ) {
> 				cur = cur.parentNode;
> 			}
> 			for ( ; cur; cur = cur.parentNode ) {
> 				eventPath.push( cur );
> 				tmp = cur;
> 			}
> 
> 			// Only add window if we got to document (e.g., not plain obj or detached DOM)
> 			if ( tmp === ( elem.ownerDocument || document ) ) {
> 				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
> 			}
> 		}
> 
> 		// Fire handlers on the event path
> 		i = 0;
> 		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
> 			lastElement = cur;
> 			event.type = i > 1 ?
> 				bubbleType :
> 				special.bindType || type;
> 
> 			// jQuery handler
> 			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
> 				dataPriv.get( cur, "handle" );
> 			if ( handle ) {
> 				handle.apply( cur, data );
> 			}
> 
> 			// Native handler
> 			handle = ontype && cur[ ontype ];
> 			if ( handle && handle.apply && acceptData( cur ) ) {
> 				event.result = handle.apply( cur, data );
> 				if ( event.result === false ) {
> 					event.preventDefault();
> 				}
> 			}
> 		}
> 		event.type = type;
> 
> 		// If nobody prevented the default action, do it now
> 		if ( !onlyHandlers && !event.isDefaultPrevented() ) {
> 
> 			if ( ( !special._default ||
> 				special._default.apply( eventPath.pop(), data ) === false ) &&
> 				acceptData( elem ) ) {
> 
> 				// Call a native DOM method on the target with the same name as the event.
> 				// Don't do default actions on window, that's where global variables be (#6170)
> 				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {
> 
> 					// Don't re-trigger an onFOO event when we call its FOO() method
> 					tmp = elem[ ontype ];
> 
> 					if ( tmp ) {
> 						elem[ ontype ] = null;
> 					}
> 
> 					// Prevent re-triggering of the same event, since we already bubbled it above
> 					jQuery.event.triggered = type;
> 
> 					if ( event.isPropagationStopped() ) {
> 						lastElement.addEventListener( type, stopPropagationCallback );
> 					}
> 
> 					elem[ type ]();
> 
> 					if ( event.isPropagationStopped() ) {
> 						lastElement.removeEventListener( type, stopPropagationCallback );
> 					}
> 
> 					jQuery.event.triggered = undefined;
> 
> 					if ( tmp ) {
> 						elem[ ontype ] = tmp;
> 					}
> 				}
> 			}
> 		}
> 
> 		return event.result;
7503,7504c8528,8550
< 	delegate: function( selector, types, data, fn ) {
< 		return this.on( types, selector, data, fn );
---
> 	// Piggyback on a donor event to simulate a different one
> 	// Used only for `focus(in | out)` events
> 	simulate: function( type, elem, event ) {
> 		var e = jQuery.extend(
> 			new jQuery.Event(),
> 			event,
> 			{
> 				type: type,
> 				isSimulated: true
> 			}
> 		);
> 
> 		jQuery.event.trigger( e, null, elem );
> 	}
> 
> } );
> 
> jQuery.fn.extend( {
> 
> 	trigger: function( type, data ) {
> 		return this.each( function() {
> 			jQuery.event.trigger( type, data, this );
> 		} );
7506,7508c8552,8556
< 	undelegate: function( selector, types, fn ) {
< 		// ( namespace ) or ( selector, types [, fn] )
< 		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
---
> 	triggerHandler: function( type, data ) {
> 		var elem = this[ 0 ];
> 		if ( elem ) {
> 			return jQuery.event.trigger( type, data, elem, true );
> 		}
7510c8558
< });
---
> } );
7513c8561,8570
< var nonce = jQuery.now();
---
> // Support: Firefox <=44
> // Firefox doesn't have focus(in | out) events
> // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
> //
> // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
> // focus(in | out) events fire after focus & blur events,
> // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
> // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
> if ( !support.focusin ) {
> 	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
7515c8572,8575
< var rquery = (/\?/);
---
> 		// Attach a single capturing handler on the document while someone wants focusin/focusout
> 		var handler = function( event ) {
> 			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
> 		};
7516a8577,8589
> 		jQuery.event.special[ fix ] = {
> 			setup: function() {
> 				var doc = this.ownerDocument || this,
> 					attaches = dataPriv.access( doc, fix );
> 
> 				if ( !attaches ) {
> 					doc.addEventListener( orig, handler, true );
> 				}
> 				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
> 			},
> 			teardown: function() {
> 				var doc = this.ownerDocument || this,
> 					attaches = dataPriv.access( doc, fix ) - 1;
7517a8591,8606
> 				if ( !attaches ) {
> 					doc.removeEventListener( orig, handler, true );
> 					dataPriv.remove( doc, fix );
> 
> 				} else {
> 					dataPriv.access( doc, fix, attaches );
> 				}
> 			}
> 		};
> 	} );
> }
> var location = window.location;
> 
> var nonce = Date.now();
> 
> var rquery = ( /\?/ );
7519,7523d8607
< // Support: Android 2.3
< // Workaround failure to string-cast null input
< jQuery.parseJSON = function( data ) {
< 	return JSON.parse( data + "" );
< };
7528c8612
< 	var xml, tmp;
---
> 	var xml;
7533c8617,8618
< 	// Support: IE9
---
> 	// Support: IE 9 - 11 only
> 	// IE throws on parseFromString with invalid input.
7535,7536c8620
< 		tmp = new DOMParser();
< 		xml = tmp.parseFromString( data, "text/xml" );
---
> 		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
7548a8633,8756
> 	rbracket = /\[\]$/,
> 	rCRLF = /\r?\n/g,
> 	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
> 	rsubmittable = /^(?:input|select|textarea|keygen)/i;
> 
> function buildParams( prefix, obj, traditional, add ) {
> 	var name;
> 
> 	if ( Array.isArray( obj ) ) {
> 
> 		// Serialize array item.
> 		jQuery.each( obj, function( i, v ) {
> 			if ( traditional || rbracket.test( prefix ) ) {
> 
> 				// Treat each array item as a scalar.
> 				add( prefix, v );
> 
> 			} else {
> 
> 				// Item is non-scalar (array or object), encode its numeric index.
> 				buildParams(
> 					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
> 					v,
> 					traditional,
> 					add
> 				);
> 			}
> 		} );
> 
> 	} else if ( !traditional && toType( obj ) === "object" ) {
> 
> 		// Serialize object item.
> 		for ( name in obj ) {
> 			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
> 		}
> 
> 	} else {
> 
> 		// Serialize scalar item.
> 		add( prefix, obj );
> 	}
> }
> 
> // Serialize an array of form elements or a set of
> // key/values into a query string
> jQuery.param = function( a, traditional ) {
> 	var prefix,
> 		s = [],
> 		add = function( key, valueOrFunction ) {
> 
> 			// If value is a function, invoke it and use its return value
> 			var value = isFunction( valueOrFunction ) ?
> 				valueOrFunction() :
> 				valueOrFunction;
> 
> 			s[ s.length ] = encodeURIComponent( key ) + "=" +
> 				encodeURIComponent( value == null ? "" : value );
> 		};
> 
> 	if ( a == null ) {
> 		return "";
> 	}
> 
> 	// If an array was passed in, assume that it is an array of form elements.
> 	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
> 
> 		// Serialize the form elements
> 		jQuery.each( a, function() {
> 			add( this.name, this.value );
> 		} );
> 
> 	} else {
> 
> 		// If traditional, encode the "old" way (the way 1.3.2 or older
> 		// did it), otherwise encode params recursively.
> 		for ( prefix in a ) {
> 			buildParams( prefix, a[ prefix ], traditional, add );
> 		}
> 	}
> 
> 	// Return the resulting serialization
> 	return s.join( "&" );
> };
> 
> jQuery.fn.extend( {
> 	serialize: function() {
> 		return jQuery.param( this.serializeArray() );
> 	},
> 	serializeArray: function() {
> 		return this.map( function() {
> 
> 			// Can add propHook for "elements" to filter or add form elements
> 			var elements = jQuery.prop( this, "elements" );
> 			return elements ? jQuery.makeArray( elements ) : this;
> 		} )
> 		.filter( function() {
> 			var type = this.type;
> 
> 			// Use .is( ":disabled" ) so that fieldset[disabled] works
> 			return this.name && !jQuery( this ).is( ":disabled" ) &&
> 				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
> 				( this.checked || !rcheckableType.test( type ) );
> 		} )
> 		.map( function( i, elem ) {
> 			var val = jQuery( this ).val();
> 
> 			if ( val == null ) {
> 				return null;
> 			}
> 
> 			if ( Array.isArray( val ) ) {
> 				return jQuery.map( val, function( val ) {
> 					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
> 				} );
> 			}
> 
> 			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
> 		} ).get();
> 	}
> } );
> 
> 
> var
> 	r20 = /%20/g,
7550c8758
< 	rts = /([?&])_=[^&]*/,
---
> 	rantiCache = /([?&])_=[^&]*/,
7551a8760
> 
7556d8764
< 	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
7579,7583c8787,8789
< 	// Document location
< 	ajaxLocation = window.location.href,
< 
< 	// Segment location into parts
< 	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];
---
> 	// Anchor tag for parsing the document origin
> 	originAnchor = document.createElement( "a" );
> 	originAnchor.href = location.href;
7598c8804,8806
< 			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];
---
> 			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
> 
> 		if ( isFunction( func ) ) {
7600d8807
< 		if ( jQuery.isFunction( func ) ) {
7602c8809,8810
< 			while ( (dataType = dataTypes[i++]) ) {
---
> 			while ( ( dataType = dataTypes[ i++ ] ) ) {
> 
7604c8812
< 				if ( dataType[0] === "+" ) {
---
> 				if ( dataType[ 0 ] === "+" ) {
7606c8814
< 					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );
---
> 					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
7610c8818
< 					(structure[ dataType ] = structure[ dataType ] || []).push( func );
---
> 					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
7628c8836,8838
< 			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
---
> 			if ( typeof dataTypeOrTransport === "string" &&
> 				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
> 
7635c8845
< 		});
---
> 		} );
7651c8861
< 			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
---
> 			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
7675c8885
< 			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
---
> 			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
7692a8903
> 
7695c8906
< 			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
---
> 			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
7702a8914
> 
7723a8936
> 
7753c8966
< 		// There's only work to do if current dataType is non-auto
---
> 			// There's only work to do if current dataType is non-auto
7775a8989
> 
7795c9009
< 					if ( conv && s[ "throws" ] ) {
---
> 					if ( conv && s.throws ) {
7801c9015,9018
< 							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
---
> 							return {
> 								state: "parsererror",
> 								error: conv ? e : "No conversion from " + prev + " to " + current
> 							};
7812c9029
< jQuery.extend({
---
> jQuery.extend( {
7822c9039
< 		url: ajaxLocation,
---
> 		url: location.href,
7824c9041
< 		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
---
> 		isLocal: rlocalProtocol.test( location.protocol ),
7828a9046
> 
7850,7852c9068,9070
< 			xml: /xml/,
< 			html: /html/,
< 			json: /json/
---
> 			xml: /\bxml\b/,
> 			html: /\bhtml/,
> 			json: /\bjson\b/
7872c9090
< 			"text json": jQuery.parseJSON,
---
> 			"text json": JSON.parse,
7916a9135
> 
7918a9138
> 
7921a9142
> 
7924,7925c9145,9151
< 			// Cross-domain detection vars
< 			parts,
---
> 
> 			// Url cleanup var
> 			urlAnchor,
> 
> 			// Request state (becomes false upon send and true upon completion)
> 			completed,
> 
7927a9154
> 
7929a9157,9160
> 
> 			// uncached part of the url
> 			uncached,
> 
7931a9163
> 
7933a9166
> 
7935,7937c9168,9172
< 			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
< 				jQuery( callbackContext ) :
< 				jQuery.event,
---
> 			globalEventContext = s.context &&
> 				( callbackContext.nodeType || callbackContext.jquery ) ?
> 					jQuery( callbackContext ) :
> 					jQuery.event,
> 
7940c9175,9176
< 			completeDeferred = jQuery.Callbacks("once memory"),
---
> 			completeDeferred = jQuery.Callbacks( "once memory" ),
> 
7942a9179
> 
7946,7947c9183
< 			// The jqXHR state
< 			state = 0,
---
> 
7949a9186
> 
7957c9194
< 					if ( state === 2 ) {
---
> 					if ( completed ) {
7960,7961c9197,9200
< 							while ( (match = rheaders.exec( responseHeadersString )) ) {
< 								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
---
> 							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
> 								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
> 									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
> 										.concat( match[ 2 ] );
7964c9203
< 						match = responseHeaders[ key.toLowerCase() ];
---
> 						match = responseHeaders[ key.toLowerCase() + " " ];
7966c9205
< 					return match == null ? null : match;
---
> 					return match == null ? null : match.join( ", " );
7971c9210
< 					return state === 2 ? responseHeadersString : null;
---
> 					return completed ? responseHeadersString : null;
7976,7978c9215,9217
< 					var lname = name.toLowerCase();
< 					if ( !state ) {
< 						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
---
> 					if ( completed == null ) {
> 						name = requestHeadersNames[ name.toLowerCase() ] =
> 							requestHeadersNames[ name.toLowerCase() ] || name;
7986c9225
< 					if ( !state ) {
---
> 					if ( completed == null ) {
7996c9235,9241
< 						if ( state < 2 ) {
---
> 						if ( completed ) {
> 
> 							// Execute the appropriate callbacks
> 							jqXHR.always( map[ jqXHR.status ] );
> 						} else {
> 
> 							// Lazy-add the new callbacks in a way that preserves old ones
7998d9242
< 								// Lazy-add the new callback in a way that preserves old ones
8001,8003d9244
< 						} else {
< 							// Execute the appropriate callbacks
< 							jqXHR.always( map[ jqXHR.status ] );
8021,8023c9262
< 		deferred.promise( jqXHR ).complete = completeDeferred.add;
< 		jqXHR.success = jqXHR.done;
< 		jqXHR.error = jqXHR.fail;
---
> 		deferred.promise( jqXHR );
8025d9263
< 		// Remove hash character (#7531: and string promotion)
8029,8030c9267,9268
< 		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
< 			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );
---
> 		s.url = ( ( url || s.url || location.href ) + "" )
> 			.replace( rprotocol, location.protocol + "//" );
8036c9274
< 		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];
---
> 		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
8038c9276
< 		// A cross-domain request is in order when we have a protocol:host:port mismatch
---
> 		// A cross-domain request is in order when the origin doesn't match the current origin.
8040,8045c9278,9296
< 			parts = rurl.exec( s.url.toLowerCase() );
< 			s.crossDomain = !!( parts &&
< 				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
< 					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
< 						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
< 			);
---
> 			urlAnchor = document.createElement( "a" );
> 
> 			// Support: IE <=8 - 11, Edge 12 - 15
> 			// IE throws exception on accessing the href property if url is malformed,
> 			// e.g. http://example.com:80x/
> 			try {
> 				urlAnchor.href = s.url;
> 
> 				// Support: IE <=8 - 11 only
> 				// Anchor's host property isn't correctly set when s.url is relative
> 				urlAnchor.href = urlAnchor.href;
> 				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
> 					urlAnchor.protocol + "//" + urlAnchor.host;
> 			} catch ( e ) {
> 
> 				// If there is an error parsing the URL, assume it is crossDomain,
> 				// it can be rejected by the transport if it is invalid
> 				s.crossDomain = true;
> 			}
8057c9308
< 		if ( state === 2 ) {
---
> 		if ( completed ) {
8067c9318
< 			jQuery.event.trigger("ajaxStart");
---
> 			jQuery.event.trigger( "ajaxStart" );
8078c9329,9330
< 		cacheURL = s.url;
---
> 		// Remove hash to simplify url manipulation
> 		cacheURL = s.url.replace( rhash, "" );
8083,8085c9335,9341
< 			// If data is available, append data to url
< 			if ( s.data ) {
< 				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
---
> 			// Remember the hash so we can put it back
> 			uncached = s.url.slice( cacheURL.length );
> 
> 			// If data is available and should be processed, append data to url
> 			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
> 				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
> 
8090c9346
< 			// Add anti-cache in url if needed
---
> 			// Add or update anti-cache param if needed
8092c9348,9350
< 				s.url = rts.test( cacheURL ) ?
---
> 				cacheURL = cacheURL.replace( rantiCache, "$1" );
> 				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
> 			}
8094,8095c9352,9353
< 					// If there is already a '_' parameter, set its value
< 					cacheURL.replace( rts, "$1_=" + nonce++ ) :
---
> 			// Put hash and anti-cache on the URL that will be requested (gh-1732)
> 			s.url = cacheURL + uncached;
8097,8099c9355,9358
< 					// Otherwise add one to the end
< 					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
< 			}
---
> 		// Change '%20' to '+' if this is encoded form body content (gh-2658)
> 		} else if ( s.data && s.processData &&
> 			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
> 			s.data = s.data.replace( r20, "+" );
8120,8121c9379,9381
< 			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
< 				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
---
> 			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
> 				s.accepts[ s.dataTypes[ 0 ] ] +
> 					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
8131c9391,9393
< 		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
---
> 		if ( s.beforeSend &&
> 			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
> 
8140,8142c9402,9404
< 		for ( i in { success: 1, error: 1, complete: 1 } ) {
< 			jqXHR[ i ]( s[ i ] );
< 		}
---
> 		completeDeferred.add( s.complete );
> 		jqXHR.done( s.success );
> 		jqXHR.fail( s.error );
8156a9419,9424
> 
> 			// If request was aborted inside ajaxSend, stop there
> 			if ( completed ) {
> 				return jqXHR;
> 			}
> 
8159,8160c9427,9428
< 				timeoutTimer = setTimeout(function() {
< 					jqXHR.abort("timeout");
---
> 				timeoutTimer = window.setTimeout( function() {
> 					jqXHR.abort( "timeout" );
8165c9433
< 				state = 1;
---
> 				completed = false;
8168,8172c9436,9438
< 				// Propagate exception as error if not done
< 				if ( state < 2 ) {
< 					done( -1, e );
< 				// Simply rethrow otherwise
< 				} else {
---
> 
> 				// Rethrow post-completion exceptions
> 				if ( completed ) {
8174a9441,9443
> 
> 				// Propagate others as results
> 				done( -1, e );
8183,8184c9452,9453
< 			// Called once
< 			if ( state === 2 ) {
---
> 			// Ignore repeat invocations
> 			if ( completed ) {
8188,8189c9457
< 			// State is "done" now
< 			state = 2;
---
> 			completed = true;
8193c9461
< 				clearTimeout( timeoutTimer );
---
> 				window.clearTimeout( timeoutTimer );
8222c9490
< 					modified = jqXHR.getResponseHeader("Last-Modified");
---
> 					modified = jqXHR.getResponseHeader( "Last-Modified" );
8226c9494
< 					modified = jqXHR.getResponseHeader("etag");
---
> 					modified = jqXHR.getResponseHeader( "etag" );
8247a9516
> 
8282a9552
> 
8285c9555
< 					jQuery.event.trigger("ajaxStop");
---
> 					jQuery.event.trigger( "ajaxStop" );
8300c9570
< });
---
> } );
8303a9574
> 
8305c9576
< 		if ( jQuery.isFunction( data ) ) {
---
> 		if ( isFunction( data ) ) {
8311c9582,9583
< 		return jQuery.ajax({
---
> 		// The url can be an options object (which then must have .url)
> 		return jQuery.ajax( jQuery.extend( {
8317c9589
< 		});
---
> 		}, jQuery.isPlainObject( url ) && url ) );
8319c9591
< });
---
> } );
8322,8323c9594,9595
< jQuery._evalUrl = function( url ) {
< 	return jQuery.ajax({
---
> jQuery._evalUrl = function( url, options ) {
> 	return jQuery.ajax( {
8324a9597,9598
> 
> 		// Make this explicit, since user can override this through ajaxSetup (#11264)
8326a9601
> 		cache: true,
8329,8330c9604,9614
< 		"throws": true
< 	});
---
> 
> 		// Only evaluate the response if it is successful (gh-4126)
> 		// dataFilter is not invoked for failure responses, so using it instead
> 		// of the default converter is kludgy but it works.
> 		converters: {
> 			"text script": function() {}
> 		},
> 		dataFilter: function( response ) {
> 			jQuery.globalEval( response, options );
> 		}
> 	} );
8334c9618
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
8338,8343d9621
< 		if ( jQuery.isFunction( html ) ) {
< 			return this.each(function( i ) {
< 				jQuery( this ).wrapAll( html.call(this, i) );
< 			});
< 		}
< 
8344a9623,9625
> 			if ( isFunction( html ) ) {
> 				html = html.call( this[ 0 ] );
> 			}
8353c9634
< 			wrap.map(function() {
---
> 			wrap.map( function() {
8361c9642
< 			}).append( this );
---
> 			} ).append( this );
8368,8371c9649,9652
< 		if ( jQuery.isFunction( html ) ) {
< 			return this.each(function( i ) {
< 				jQuery( this ).wrapInner( html.call(this, i) );
< 			});
---
> 		if ( isFunction( html ) ) {
> 			return this.each( function( i ) {
> 				jQuery( this ).wrapInner( html.call( this, i ) );
> 			} );
8374c9655
< 		return this.each(function() {
---
> 		return this.each( function() {
8384c9665
< 		});
---
> 		} );
8388c9669
< 		var isFunction = jQuery.isFunction( html );
---
> 		var htmlIsFunction = isFunction( html );
8390,8392c9671,9673
< 		return this.each(function( i ) {
< 			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
< 		});
---
> 		return this.each( function( i ) {
> 			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
> 		} );
8395,8400c9676,9680
< 	unwrap: function() {
< 		return this.parent().each(function() {
< 			if ( !jQuery.nodeName( this, "body" ) ) {
< 				jQuery( this ).replaceWith( this.childNodes );
< 			}
< 		}).end();
---
> 	unwrap: function( selector ) {
> 		this.parent( selector ).not( "body" ).each( function() {
> 			jQuery( this ).replaceWith( this.childNodes );
> 		} );
> 		return this;
8402c9682
< });
---
> } );
8405,8411c9685,9686
< jQuery.expr.filters.hidden = function( elem ) {
< 	// Support: Opera <= 12.12
< 	// Opera reports offsetWidths and offsetHeights less than zero on some elements
< 	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
< };
< jQuery.expr.filters.visible = function( elem ) {
< 	return !jQuery.expr.filters.hidden( elem );
---
> jQuery.expr.pseudos.hidden = function( elem ) {
> 	return !jQuery.expr.pseudos.visible( elem );
8413,8483c9688,9689
< 
< 
< 
< 
< var r20 = /%20/g,
< 	rbracket = /\[\]$/,
< 	rCRLF = /\r?\n/g,
< 	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
< 	rsubmittable = /^(?:input|select|textarea|keygen)/i;
< 
< function buildParams( prefix, obj, traditional, add ) {
< 	var name;
< 
< 	if ( jQuery.isArray( obj ) ) {
< 		// Serialize array item.
< 		jQuery.each( obj, function( i, v ) {
< 			if ( traditional || rbracket.test( prefix ) ) {
< 				// Treat each array item as a scalar.
< 				add( prefix, v );
< 
< 			} else {
< 				// Item is non-scalar (array or object), encode its numeric index.
< 				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
< 			}
< 		});
< 
< 	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
< 		// Serialize object item.
< 		for ( name in obj ) {
< 			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
< 		}
< 
< 	} else {
< 		// Serialize scalar item.
< 		add( prefix, obj );
< 	}
< }
< 
< // Serialize an array of form elements or a set of
< // key/values into a query string
< jQuery.param = function( a, traditional ) {
< 	var prefix,
< 		s = [],
< 		add = function( key, value ) {
< 			// If value is a function, invoke it and return its value
< 			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
< 			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
< 		};
< 
< 	// Set traditional to true for jQuery <= 1.3.2 behavior.
< 	if ( traditional === undefined ) {
< 		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
< 	}
< 
< 	// If an array was passed in, assume that it is an array of form elements.
< 	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
< 		// Serialize the form elements
< 		jQuery.each( a, function() {
< 			add( this.name, this.value );
< 		});
< 
< 	} else {
< 		// If traditional, encode the "old" way (the way 1.3.2 or older
< 		// did it), otherwise encode params recursively.
< 		for ( prefix in a ) {
< 			buildParams( prefix, a[ prefix ], traditional, add );
< 		}
< 	}
< 
< 	// Return the resulting serialization
< 	return s.join( "&" ).replace( r20, "+" );
---
> jQuery.expr.pseudos.visible = function( elem ) {
> 	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
8486,8505d9691
< jQuery.fn.extend({
< 	serialize: function() {
< 		return jQuery.param( this.serializeArray() );
< 	},
< 	serializeArray: function() {
< 		return this.map(function() {
< 			// Can add propHook for "elements" to filter or add form elements
< 			var elements = jQuery.prop( this, "elements" );
< 			return elements ? jQuery.makeArray( elements ) : this;
< 		})
< 		.filter(function() {
< 			var type = this.type;
< 
< 			// Use .is( ":disabled" ) so that fieldset[disabled] works
< 			return this.name && !jQuery( this ).is( ":disabled" ) &&
< 				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
< 				( this.checked || !rcheckableType.test( type ) );
< 		})
< 		.map(function( i, elem ) {
< 			var val = jQuery( this ).val();
8507,8516d9692
< 			return val == null ?
< 				null :
< 				jQuery.isArray( val ) ?
< 					jQuery.map( val, function( val ) {
< 						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
< 					}) :
< 					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
< 		}).get();
< 	}
< });
8521,8522c9697,9698
< 		return new XMLHttpRequest();
< 	} catch( e ) {}
---
> 		return new window.XMLHttpRequest();
> 	} catch ( e ) {}
8525,8528c9701,9703
< var xhrId = 0,
< 	xhrCallbacks = {},
< 	xhrSuccessStatus = {
< 		// file protocol always yields status code 0, assume 200
---
> var xhrSuccessStatus = {
> 
> 		// File protocol always yields status code 0, assume 200
8530c9705,9706
< 		// Support: IE9
---
> 
> 		// Support: IE <=9 only
8536,8546d9711
< // Support: IE9
< // Open requests must be manually aborted on unload (#5280)
< // See https://support.microsoft.com/kb/2856746 for more info
< if ( window.attachEvent ) {
< 	window.attachEvent( "onunload", function() {
< 		for ( var key in xhrCallbacks ) {
< 			xhrCallbacks[ key ]();
< 		}
< 	});
< }
< 
8550,8551c9715,9716
< jQuery.ajaxTransport(function( options ) {
< 	var callback;
---
> jQuery.ajaxTransport( function( options ) {
> 	var callback, errorCallback;
8558,8559c9723
< 					xhr = options.xhr(),
< 					id = ++xhrId;
---
> 					xhr = options.xhr();
8561c9725,9731
< 				xhr.open( options.type, options.url, options.async, options.username, options.password );
---
> 				xhr.open(
> 					options.type,
> 					options.url,
> 					options.async,
> 					options.username,
> 					options.password
> 				);
8580,8581c9750,9751
< 				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
< 					headers["X-Requested-With"] = "XMLHttpRequest";
---
> 				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
> 					headers[ "X-Requested-With" ] = "XMLHttpRequest";
8593,8594c9763,9765
< 							delete xhrCallbacks[ id ];
< 							callback = xhr.onload = xhr.onerror = null;
---
> 							callback = errorCallback = xhr.onload =
> 								xhr.onerror = xhr.onabort = xhr.ontimeout =
> 									xhr.onreadystatechange = null;
8599,8603c9770,9783
< 								complete(
< 									// file: protocol always yields status 0; see #8605, #14207
< 									xhr.status,
< 									xhr.statusText
< 								);
---
> 
> 								// Support: IE <=9 only
> 								// On a manual native abort, IE9 throws
> 								// errors on any property access that is not readyState
> 								if ( typeof xhr.status !== "number" ) {
> 									complete( 0, "error" );
> 								} else {
> 									complete(
> 
> 										// File: protocol always yields status 0; see #8605, #14207
> 										xhr.status,
> 										xhr.statusText
> 									);
> 								}
8608,8613c9788,9795
< 									// Support: IE9
< 									// Accessing binary-data responseText throws an exception
< 									// (#11426)
< 									typeof xhr.responseText === "string" ? {
< 										text: xhr.responseText
< 									} : undefined,
---
> 
> 									// Support: IE <=9 only
> 									// IE9 has no XHR2 but throws on binary (trac-11426)
> 									// For XHR2 non-text, let the caller handle it (gh-2498)
> 									( xhr.responseType || "text" ) !== "text"  ||
> 									typeof xhr.responseText !== "string" ?
> 										{ binary: xhr.response } :
> 										{ text: xhr.responseText },
8623c9805,9829
< 				xhr.onerror = callback("error");
---
> 				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );
> 
> 				// Support: IE 9 only
> 				// Use onreadystatechange to replace onabort
> 				// to handle uncaught aborts
> 				if ( xhr.onabort !== undefined ) {
> 					xhr.onabort = errorCallback;
> 				} else {
> 					xhr.onreadystatechange = function() {
> 
> 						// Check readyState before timeout as it changes
> 						if ( xhr.readyState === 4 ) {
> 
> 							// Allow onerror to be called first,
> 							// but that will not handle a native abort
> 							// Also, save errorCallback to a variable
> 							// as xhr.onerror cannot be accessed
> 							window.setTimeout( function() {
> 								if ( callback ) {
> 									errorCallback();
> 								}
> 							} );
> 						}
> 					};
> 				}
8626c9832
< 				callback = xhrCallbacks[ id ] = callback("abort");
---
> 				callback = callback( "abort" );
8628a9835
> 
8631a9839
> 
8646c9854
< });
---
> } );
8650a9859,9865
> // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
> jQuery.ajaxPrefilter( function( s ) {
> 	if ( s.crossDomain ) {
> 		s.contents.script = false;
> 	}
> } );
> 
8652c9867
< jQuery.ajaxSetup({
---
> jQuery.ajaxSetup( {
8654c9869,9870
< 		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
---
> 		script: "text/javascript, application/javascript, " +
> 			"application/ecmascript, application/x-ecmascript"
8657c9873
< 		script: /(?:java|ecma)script/
---
> 		script: /\b(?:java|ecma)script\b/
8665c9881
< });
---
> } );
8675c9891
< });
---
> } );
8679,8680c9895,9897
< 	// This transport only deals with cross domain requests
< 	if ( s.crossDomain ) {
---
> 
> 	// This transport only deals with cross domain or forced-by-attrs requests
> 	if ( s.crossDomain || s.scriptAttrs ) {
8684,8690c9901,9904
< 				script = jQuery("<script>").prop({
< 					async: true,
< 					charset: s.scriptCharset,
< 					src: s.url
< 				}).on(
< 					"load error",
< 					callback = function( evt ) {
---
> 				script = jQuery( "<script>" )
> 					.attr( s.scriptAttrs || {} )
> 					.prop( { charset: s.scriptCharset, src: s.url } )
> 					.on( "load error", callback = function( evt ) {
8696,8697c9910,9912
< 					}
< 				);
---
> 					} );
> 
> 				// Use native DOM manipulation to avoid our domManip AJAX trickery
8707c9922
< });
---
> } );
8716c9931
< jQuery.ajaxSetup({
---
> jQuery.ajaxSetup( {
8723c9938
< });
---
> } );
8731c9946,9949
< 			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
---
> 			typeof s.data === "string" &&
> 				( s.contentType || "" )
> 					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
> 				rjsonp.test( s.data ) && "data"
8738c9956
< 		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
---
> 		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
8750c9968
< 		s.converters["script json"] = function() {
---
> 		s.converters[ "script json" ] = function() {
8757c9975
< 		// force json dataType
---
> 		// Force json dataType
8767,8769c9985,9994
< 		jqXHR.always(function() {
< 			// Restore preexisting value
< 			window[ callbackName ] = overwritten;
---
> 		jqXHR.always( function() {
> 
> 			// If previous value didn't exist - remove it
> 			if ( overwritten === undefined ) {
> 				jQuery( window ).removeProp( callbackName );
> 
> 			// Otherwise restore preexisting value
> 			} else {
> 				window[ callbackName ] = overwritten;
> 			}
8773c9998,9999
< 				// make sure that re-using the options doesn't screw things around
---
> 
> 				// Make sure that re-using the options doesn't screw things around
8776c10002
< 				// save the callback name for future use
---
> 				// Save the callback name for future use
8781c10007
< 			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
---
> 			if ( responseContainer && isFunction( overwritten ) ) {
8786c10012
< 		});
---
> 		} );
8791c10017,10018
< });
---
> } );
> 
8794a10022,10031
> // Support: Safari 8 only
> // In Safari 8 documents created via document.implementation.createHTMLDocument
> // collapse sibling forms: the second one becomes a child of the first one.
> // Because of that, this security measure has to be disabled in Safari 8.
> // https://bugs.webkit.org/show_bug.cgi?id=137337
> support.createHTMLDocument = ( function() {
> 	var body = document.implementation.createHTMLDocument( "" ).body;
> 	body.innerHTML = "<form></form><form></form>";
> 	return body.childNodes.length === 2;
> } )();
8796,8797c10033,10036
< // data: string of html
< // context (optional): If specified, the fragment will be created in this context, defaults to document
---
> 
> // Argument "data" should be string of html
> // context (optional): If specified, the fragment will be created in this context,
> // defaults to document
8800,8801c10039,10040
< 	if ( !data || typeof data !== "string" ) {
< 		return null;
---
> 	if ( typeof data !== "string" ) {
> 		return [];
8807d10045
< 	context = context || document;
8809,8810c10047,10068
< 	var parsed = rsingleTag.exec( data ),
< 		scripts = !keepScripts && [];
---
> 	var base, parsed, scripts;
> 
> 	if ( !context ) {
> 
> 		// Stop scripts or inline event handlers from being executed immediately
> 		// by using document.implementation
> 		if ( support.createHTMLDocument ) {
> 			context = document.implementation.createHTMLDocument( "" );
> 
> 			// Set the base href for the created document
> 			// so any parsed elements with URLs
> 			// are based on the document's URL (gh-2965)
> 			base = context.createElement( "base" );
> 			base.href = document.location.href;
> 			context.head.appendChild( base );
> 		} else {
> 			context = document;
> 		}
> 	}
> 
> 	parsed = rsingleTag.exec( data );
> 	scripts = !keepScripts && [];
8814c10072
< 		return [ context.createElement( parsed[1] ) ];
---
> 		return [ context.createElement( parsed[ 1 ] ) ];
8817c10075
< 	parsed = jQuery.buildFragment( [ data ], context, scripts );
---
> 	parsed = buildFragment( [ data ], context, scripts );
8827,8829d10084
< // Keep a copy of the old load method
< var _load = jQuery.fn.load;
< 
8834,8837d10088
< 	if ( typeof url !== "string" && _load ) {
< 		return _load.apply( this, arguments );
< 	}
< 
8840c10091
< 		off = url.indexOf(" ");
---
> 		off = url.indexOf( " " );
8842,8843c10093,10094
< 	if ( off >= 0 ) {
< 		selector = jQuery.trim( url.slice( off ) );
---
> 	if ( off > -1 ) {
> 		selector = stripAndCollapse( url.slice( off ) );
8848c10099
< 	if ( jQuery.isFunction( params ) ) {
---
> 	if ( isFunction( params ) ) {
8861c10112
< 		jQuery.ajax({
---
> 		jQuery.ajax( {
8864,8865c10115,10118
< 			// if "type" variable is undefined, then "GET" method will be used
< 			type: type,
---
> 			// If "type" variable is undefined, then "GET" method will be used.
> 			// Make value of this field explicit since
> 			// user can override it through ajaxSetup method
> 			type: type || "GET",
8868c10121
< 		}).done(function( responseText ) {
---
> 		} ).done( function( responseText ) {
8877c10130
< 				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :
---
> 				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
8882,8884c10135,10142
< 		}).complete( callback && function( jqXHR, status ) {
< 			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
< 		});
---
> 		// If the request succeeds, this function gets "data", "status", "jqXHR"
> 		// but they are ignored because response was set above.
> 		// If it fails, this function gets "jqXHR", "status", "error"
> 		} ).always( callback && function( jqXHR, status ) {
> 			self.each( function() {
> 				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
> 			} );
> 		} );
8894c10152,10159
< jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
---
> jQuery.each( [
> 	"ajaxStart",
> 	"ajaxStop",
> 	"ajaxComplete",
> 	"ajaxError",
> 	"ajaxSuccess",
> 	"ajaxSend"
> ], function( i, type ) {
8898c10163
< });
---
> } );
8903,8904c10168,10169
< jQuery.expr.filters.animated = function( elem ) {
< 	return jQuery.grep(jQuery.timers, function( fn ) {
---
> jQuery.expr.pseudos.animated = function( elem ) {
> 	return jQuery.grep( jQuery.timers, function( fn ) {
8906c10171
< 	}).length;
---
> 	} ).length;
8912,8920d10176
< var docElem = window.document.documentElement;
< 
< /**
<  * Gets a window from an element
<  */
< function getWindow( elem ) {
< 	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
< }
< 
8937c10193
< 			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;
---
> 			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
8951,8952c10207,10210
< 		if ( jQuery.isFunction( options ) ) {
< 			options = options.call( elem, i, curOffset );
---
> 		if ( isFunction( options ) ) {
> 
> 			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
> 			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
8971c10229,10231
< jQuery.fn.extend({
---
> jQuery.fn.extend( {
> 
> 	// offset() relates an element's border box to the document origin
8972a10233,10234
> 
> 		// Preserve chaining for setter
8976c10238
< 				this.each(function( i ) {
---
> 				this.each( function( i ) {
8978c10240
< 				});
---
> 				} );
8981,8984c10243,10244
< 		var docElem, win,
< 			elem = this[ 0 ],
< 			box = { top: 0, left: 0 },
< 			doc = elem && elem.ownerDocument;
---
> 		var rect, win,
> 			elem = this[ 0 ];
8986c10246
< 		if ( !doc ) {
---
> 		if ( !elem ) {
8990,8994c10250,10255
< 		docElem = doc.documentElement;
< 
< 		// Make sure it's not a disconnected DOM node
< 		if ( !jQuery.contains( docElem, elem ) ) {
< 			return box;
---
> 		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
> 		// Support: IE <=11 only
> 		// Running getBoundingClientRect on a
> 		// disconnected node in IE throws an error
> 		if ( !elem.getClientRects().length ) {
> 			return { top: 0, left: 0 };
8997,9002c10258,10260
< 		// Support: BlackBerry 5, iOS 3 (original iPhone)
< 		// If we don't have gBCR, just use 0,0 rather than error
< 		if ( typeof elem.getBoundingClientRect !== strundefined ) {
< 			box = elem.getBoundingClientRect();
< 		}
< 		win = getWindow( doc );
---
> 		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
> 		rect = elem.getBoundingClientRect();
> 		win = elem.ownerDocument.defaultView;
9004,9005c10262,10263
< 			top: box.top + win.pageYOffset - docElem.clientTop,
< 			left: box.left + win.pageXOffset - docElem.clientLeft
---
> 			top: rect.top + win.pageYOffset,
> 			left: rect.left + win.pageXOffset
9008a10267,10268
> 	// position() relates an element's margin box to its offset parent's padding box
> 	// This corresponds to the behavior of CSS absolute positioning
9014c10274
< 		var offsetParent, offset,
---
> 		var offsetParent, offset, doc,
9018c10278
< 		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
---
> 		// position:fixed elements are offset from the viewport, which itself always has zero offset
9020c10280,10281
< 			// Assume getBoundingClientRect is there when computed position is fixed
---
> 
> 			// Assume position:fixed implies availability of getBoundingClientRect
9024,9027d10284
< 			// Get *real* offsetParent
< 			offsetParent = this.offsetParent();
< 
< 			// Get correct offsets
9029,9031d10285
< 			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
< 				parentOffset = offsetParent.offset();
< 			}
9033,9035c10287,10303
< 			// Add offsetParent borders
< 			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
< 			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
---
> 			// Account for the *real* offset parent, which can be the document or its root element
> 			// when a statically positioned element is identified
> 			doc = elem.ownerDocument;
> 			offsetParent = elem.offsetParent || doc.documentElement;
> 			while ( offsetParent &&
> 				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
> 				jQuery.css( offsetParent, "position" ) === "static" ) {
> 
> 				offsetParent = offsetParent.parentNode;
> 			}
> 			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {
> 
> 				// Incorporate borders into its offset, since they are outside its content origin
> 				parentOffset = jQuery( offsetParent ).offset();
> 				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
> 				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
> 			}
9044a10313,10322
> 	// This method will return documentElement in the following cases:
> 	// 1) For the element inside the iframe without offsetParent, this method will return
> 	//    documentElement of the parent window
> 	// 2) For the hidden or detached element
> 	// 3) For body or html element, i.e. in case of the html node - it will return itself
> 	//
> 	// but those exceptions were never presented as a real life use-cases
> 	// and might be considered as more preferable results.
> 	//
> 	// This logic, however, is not guaranteed and can change at any point in the future
9046,9047c10324,10325
< 		return this.map(function() {
< 			var offsetParent = this.offsetParent || docElem;
---
> 		return this.map( function() {
> 			var offsetParent = this.offsetParent;
9049c10327
< 			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
---
> 			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
9053,9054c10331,10332
< 			return offsetParent || docElem;
< 		});
---
> 			return offsetParent || documentElement;
> 		} );
9056c10334
< });
---
> } );
9064c10342,10349
< 			var win = getWindow( elem );
---
> 
> 			// Coalesce documents and windows
> 			var win;
> 			if ( isWindow( elem ) ) {
> 				win = elem;
> 			} else if ( elem.nodeType === 9 ) {
> 				win = elem.defaultView;
> 			}
9072,9073c10357,10358
< 					!top ? val : window.pageXOffset,
< 					top ? val : window.pageYOffset
---
> 					!top ? val : win.pageXOffset,
> 					top ? val : win.pageYOffset
9079c10364
< 		}, method, val, arguments.length, null );
---
> 		}, method, val, arguments.length );
9081c10366
< });
---
> } );
9083c10368
< // Support: Safari<7+, Chrome<37+
---
> // Support: Safari <=7 - 9.1, Chrome <=37 - 49
9086c10371
< // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
---
> // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
9093a10379
> 
9101c10387
< });
---
> } );
9106c10392,10394
< 	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
---
> 	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
> 		function( defaultExtra, funcName ) {
> 
9115,9119c10403,10408
< 				if ( jQuery.isWindow( elem ) ) {
< 					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
< 					// isn't a whole lot we can do. See pull request at this URL for discussion:
< 					// https://github.com/jquery/jquery/pull/764
< 					return elem.document.documentElement[ "client" + name ];
---
> 				if ( isWindow( elem ) ) {
> 
> 					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
> 					return funcName.indexOf( "outer" ) === 0 ?
> 						elem[ "inner" + name ] :
> 						elem.document.documentElement[ "client" + name ];
9135a10425
> 
9141c10431
< 			}, type, chainable ? margin : undefined, chainable, null );
---
> 			}, type, chainable ? margin : undefined, chainable );
9143,9144c10433,10503
< 	});
< });
---
> 	} );
> } );
> 
> 
> jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
> 	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
> 	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
> 	function( i, name ) {
> 
> 	// Handle event binding
> 	jQuery.fn[ name ] = function( data, fn ) {
> 		return arguments.length > 0 ?
> 			this.on( name, null, data, fn ) :
> 			this.trigger( name );
> 	};
> } );
> 
> jQuery.fn.extend( {
> 	hover: function( fnOver, fnOut ) {
> 		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
> 	}
> } );
> 
> 
> 
> 
> jQuery.fn.extend( {
> 
> 	bind: function( types, data, fn ) {
> 		return this.on( types, null, data, fn );
> 	},
> 	unbind: function( types, fn ) {
> 		return this.off( types, null, fn );
> 	},
> 
> 	delegate: function( selector, types, data, fn ) {
> 		return this.on( types, selector, data, fn );
> 	},
> 	undelegate: function( selector, types, fn ) {
> 
> 		// ( namespace ) or ( selector, types [, fn] )
> 		return arguments.length === 1 ?
> 			this.off( selector, "**" ) :
> 			this.off( types, selector || "**", fn );
> 	}
> } );
> 
> // Bind a function to a context, optionally partially applying any
> // arguments.
> // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
> // However, it is not slated for removal any time soon
> jQuery.proxy = function( fn, context ) {
> 	var tmp, args, proxy;
> 
> 	if ( typeof context === "string" ) {
> 		tmp = fn[ context ];
> 		context = fn;
> 		fn = tmp;
> 	}
> 
> 	// Quick check to determine if target is callable, in the spec
> 	// this throws a TypeError, but we will just return undefined.
> 	if ( !isFunction( fn ) ) {
> 		return undefined;
> 	}
> 
> 	// Simulated bind
> 	args = slice.call( arguments, 2 );
> 	proxy = function() {
> 		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
> 	};
9145a10505,10506
> 	// Set the guid of unique handler to the same of original handler, so it can be removed
> 	proxy.guid = fn.guid = fn.guid || jQuery.guid++;
9147,9149c10508
< // The number of elements contained in the matched element set
< jQuery.fn.size = function() {
< 	return this.length;
---
> 	return proxy;
9152c10511,10540
< jQuery.fn.andSelf = jQuery.fn.addBack;
---
> jQuery.holdReady = function( hold ) {
> 	if ( hold ) {
> 		jQuery.readyWait++;
> 	} else {
> 		jQuery.ready( true );
> 	}
> };
> jQuery.isArray = Array.isArray;
> jQuery.parseJSON = JSON.parse;
> jQuery.nodeName = nodeName;
> jQuery.isFunction = isFunction;
> jQuery.isWindow = isWindow;
> jQuery.camelCase = camelCase;
> jQuery.type = toType;
> 
> jQuery.now = Date.now;
> 
> jQuery.isNumeric = function( obj ) {
> 
> 	// As of jQuery 3.0, isNumeric is limited to
> 	// strings and numbers (primitives or objects)
> 	// that can be coerced to finite numbers (gh-2662)
> 	var type = jQuery.type( obj );
> 	return ( type === "number" || type === "string" ) &&
> 
> 		// parseFloat NaNs numeric-cast false positives ("")
> 		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
> 		// subtraction forces infinities to NaN
> 		!isNaN( obj - parseFloat( obj ) );
> };
9173c10561
< 	});
---
> 	} );
9179a10568
> 
9201c10590
< if ( typeof noGlobal === strundefined ) {
---
> if ( !noGlobal ) {
9209,9210c10598
< 
< }));
---
> } );
9213c10601
<  * Lightbox v2.9.0
---
>  * Lightbox v2.11.2
9219c10607
<  * Copyright 2007, 2015 Lokesh Dhakar
---
>  * Copyright Lokesh Dhakar
9221a10610,10611
>  *
>  * @preserve
9305a10696,10699
>     if ($('#lightbox').length > 0) {
>         return;
>     }
> 
9307c10701,10713
<     $('<div id="lightboxOverlay" class="lightboxOverlay"></div><div id="lightbox" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" /><div class="lb-nav"><a class="lb-prev" href="" ></a><a class="lb-next" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo($('body'));
---
> 
>     // The two root notes generated, #lightboxOverlay and #lightbox are given
>     // tabindex attrs so they are focusable. We attach our keyboard event
>     // listeners to these two elements, and not the document. Clicking anywhere
>     // while Lightbox is opened will keep the focus on or inside one of these
>     // two elements.
>     //
>     // We do this so we can prevent propogation of the Esc keypress when
>     // Lightbox is open. This prevents it from intefering with other components
>     // on the page below.
>     //
>     // Github issue: https://github.com/lokesh/lightbox2/issues/663
>     $('<div id="lightboxOverlay" tabindex="-1" class="lightboxOverlay"></div><div id="lightbox" tabindex="-1" class="lightbox"><div class="lb-outerContainer"><div class="lb-container"><img class="lb-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" alt=""/><div class="lb-nav"><a class="lb-prev" aria-label="Previous image" href="" ></a><a class="lb-next" aria-label="Next image" href="" ></a></div><div class="lb-loader"><a class="lb-cancel"></a></div></div></div><div class="lb-dataContainer"><div class="lb-data"><div class="lb-details"><span class="lb-caption"></span><span class="lb-number"></span></div><div class="lb-closeContainer"><a class="lb-close"></a></div></div></div></div>').appendTo($('body'));
9342d10747
<       return false;
9409,9412d10813
<     $('select, object, embed').css({
<       visibility: 'hidden'
<     });
< 
9419a10821
>         alt: $link.attr('data-alt'),
9471a10874,10876
>     var filename = this.album[imageNumber].link;
>     var filetype = filename.split('.').slice(-1)[0];
>     var $image = this.$lightbox.find('.lb-image');
9472a10878
>     // Disable keyboard nav during transitions
9474d10879
<     var $image = this.$lightbox.find('.lb-image');
9475a10881
>     // Show loading state
9477d10882
< 
9480d10884
< 
9494c10898,10901
<       $image.attr('src', self.album[imageNumber].link);
---
>       $image.attr({
>         'alt': self.album[imageNumber].alt,
>         'src': filename
>       });
9499a10907,10908
>       windowWidth = $(window).width();
>       windowHeight = $(window).height();
9501,9503c10910,10923
<       if (self.options.fitImagesInViewport) {
<         // Fit image inside the viewport.
<         // Take into account the border around the image and an additional 10px gutter on each side.
---
>       // Calculate the max image dimensions for the current viewport.
>       // Take into account the border around the image and an additional 10px gutter on each side.
>       maxImageWidth  = windowWidth - self.containerPadding.left - self.containerPadding.right - self.imageBorderWidth.left - self.imageBorderWidth.right - 20;
>       maxImageHeight = windowHeight - self.containerPadding.top - self.containerPadding.bottom - self.imageBorderWidth.top - self.imageBorderWidth.bottom - self.options.positionFromTop - 70;
> 
>       /*
>       Since many SVGs have small intrinsic dimensions, but they support scaling
>       up without quality loss because of their vector format, max out their
>       size.
>       */
>       if (filetype === 'svg') {
>         $image.width(maxImageWidth);
>         $image.height(maxImageHeight);
>       }
9505,9510c10925,10926
< /* modified by Cliff */
<         windowWidth    = window.innerWidth;
<         windowHeight   = window.innerHeight;
< /* end modified by Cliff */
<         maxImageWidth  = windowWidth - self.containerPadding.left - self.containerPadding.right - self.imageBorderWidth.left - self.imageBorderWidth.right - 20;
<         maxImageHeight = windowHeight - self.containerPadding.top - self.containerPadding.bottom - self.imageBorderWidth.top - self.imageBorderWidth.bottom - 120;
---
>       // Fit image inside the viewport.
>       if (self.options.fitImagesInViewport) {
9516c10932
<         if (self.options.maxHeight && self.options.maxHeight < maxImageWidth) {
---
>         if (self.options.maxHeight && self.options.maxHeight < maxImageHeight) {
9520,9532c10936,10953
<         // Is there a fitting issue?
<         if ((preloader.width > maxImageWidth) || (preloader.height > maxImageHeight)) {
<           if ((preloader.width / maxImageWidth) > (preloader.height / maxImageHeight)) {
<             imageWidth  = maxImageWidth;
<             imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10);
<             $image.width(imageWidth);
<             $image.height(imageHeight);
<           } else {
<             imageHeight = maxImageHeight;
<             imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10);
<             $image.width(imageWidth);
<             $image.height(imageHeight);
<           }
---
>       } else {
>         maxImageWidth = self.options.maxWidth || preloader.width || maxImageWidth;
>         maxImageHeight = self.options.maxHeight || preloader.height || maxImageHeight;
>       }
> 
>       // Is the current image's width or height is greater than the maxImageWidth or maxImageHeight
>       // option than we need to size down while maintaining the aspect ratio.
>       if ((preloader.width > maxImageWidth) || (preloader.height > maxImageHeight)) {
>         if ((preloader.width / maxImageWidth) > (preloader.height / maxImageHeight)) {
>           imageWidth  = maxImageWidth;
>           imageHeight = parseInt(preloader.height / (preloader.width / imageWidth), 10);
>           $image.width(imageWidth);
>           $image.height(imageHeight);
>         } else {
>           imageHeight = maxImageHeight;
>           imageWidth = parseInt(preloader.width / (preloader.height / imageHeight), 10);
>           $image.width(imageWidth);
>           $image.height(imageHeight);
9538c10959,10960
<     preloader.src          = this.album[imageNumber].link;
---
>     // Preload image before showing
>     preloader.src = this.album[imageNumber].link;
9544,9546c10966,10979
<     this.$overlay
<       .width($(document).width())
<       .height($(document).height());
---
>     var self = this;
>     /*
>     We use a setTimeout 0 to pause JS execution and let the rendering catch-up.
>     Why do this? If the `disableScrolling` option is set to true, a class is added to the body
>     tag that disables scrolling and hides the scrollbar. We want to make sure the scrollbar is
>     hidden before we measure the document width, as the presence of the scrollbar will affect the
>     number.
>     */
>     setTimeout(function() {
>       self.$overlay
>         .width($(document).width())
>         .height($(document).height());
> 
>     }, 0);
9549a10983
>   // This method also shows the the image.
9561a10996,10999
> 
>       // Set focus on one of the two root nodes so keyboard events are captured.
>       self.$overlay.focus();
> 
9638,9645c11076
<       $caption.fadeIn('fast')
<         .find('a').on('click', function(event) {
<           if ($(this).attr('target') !== undefined) {
<             window.open($(this).attr('href'), $(this).attr('target'));
<           } else {
<             location.href = $(this).attr('href');
<           }
<         });
---
>       $caption.fadeIn('fast');
9675c11106,11107
<     $(document).on('keyup.keyboard', $.proxy(this.keyboardAction, this));
---
>     this.$lightbox.on('keyup.keyboard', $.proxy(this.keyboardAction, this));
>     this.$overlay.on('keyup.keyboard', $.proxy(this.keyboardAction, this));
9679c11111,11112
<     $(document).off('.keyboard');
---
>     this.$lightbox.off('.keyboard');
>     this.$overlay.off('.keyboard');
9688,9689c11121,11123
<     var key     = String.fromCharCode(keycode).toLowerCase();
<     if (keycode === KEYCODE_ESC || key.match(/x|o|c/)) {
---
>     if (keycode === KEYCODE_ESC) {
>       // Prevent bubbling so as to not affect other components on the page.
>       event.stopPropagation();
9691c11125
<     } else if (key === 'p' || keycode === KEYCODE_LEFTARROW) {
---
>     } else if (keycode === KEYCODE_LEFTARROW) {
9697c11131
<     } else if (key === 'n' || keycode === KEYCODE_RIGHTARROW) {
---
>     } else if (keycode === KEYCODE_RIGHTARROW) {
9712,9714c11146
<     $('select, object, embed').css({
<       visibility: 'visible'
<     });
---
> 
9721a11154
> 
